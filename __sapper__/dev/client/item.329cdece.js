import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, o as svg_element, f as claim_element, g as children, b as detach_dev, j as attr_dev, k as add_location, l as insert_dev, m as append_dev, n as noop, w as writable, p as derived, r as validate_store, u as component_subscribe, e as element, x as null_to_empty, y as toggle_class, z as listen_dev, A as create_component, B as claim_component, C as mount_component, D as transition_in, E as transition_out, F as destroy_component, G as empty, H as HtmlTag, I as validate_each_argument, t as text, h as claim_text, J as set_data_dev, a as space, c as claim_space, K as run_all, L as destroy_each, M as group_outros, N as check_outros, O as onMount, P as set_style, Q as create_slot, R as onDestroy, T as update_slot, U as createEventDispatcher, V as prop_dev, W as binding_callbacks, X as bind, Y as prevent_default, Z as add_flush_callback, _ as is_function, q as query_selector_all } from './client.4bb4aa6f.js';

/* node_modules\svelte-feather-icons\src\icons\EditIcon.svelte generated by Svelte v3.36.0 */

const file$c = "node_modules\\svelte-feather-icons\\src\\icons\\EditIcon.svelte";

function create_fragment$c(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			svg = claim_element(
				nodes,
				"svg",
				{
					xmlns: true,
					width: true,
					height: true,
					fill: true,
					viewBox: true,
					stroke: true,
					"stroke-width": true,
					"stroke-linecap": true,
					"stroke-linejoin": true,
					class: true
				},
				1
			);

			var svg_nodes = children(svg);
			path0 = claim_element(svg_nodes, "path", { d: true }, 1);
			children(path0).forEach(detach_dev);
			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
			children(path1).forEach(detach_dev);
			svg_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path0, "d", "M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7");
			add_location(path0, file$c, 13, 241, 527);
			attr_dev(path1, "d", "M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z");
			add_location(path1, file$c, 13, 317, 603);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "width", /*size*/ ctx[0]);
			attr_dev(svg, "height", /*size*/ ctx[0]);
			attr_dev(svg, "fill", "none");
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "stroke", "currentColor");
			attr_dev(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			attr_dev(svg, "stroke-linecap", "round");
			attr_dev(svg, "stroke-linejoin", "round");
			attr_dev(svg, "class", svg_class_value = "feather feather-edit " + /*customClass*/ ctx[2]);
			add_location(svg, file$c, 13, 0, 286);
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path0);
			append_dev(svg, path1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size*/ 1) {
				attr_dev(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr_dev(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*strokeWidth*/ 2) {
				attr_dev(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			}

			if (dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "feather feather-edit " + /*customClass*/ ctx[2])) {
				attr_dev(svg, "class", svg_class_value);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$c.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$c($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("EditIcon", slots, []);
	let { size = "100%" } = $$props;
	let { strokeWidth = 2 } = $$props;
	let { class: customClass = "" } = $$props;

	if (size !== "100%") {
		size = size.slice(-1) === "x"
		? size.slice(0, size.length - 1) + "em"
		: parseInt(size) + "px";
	}

	const writable_props = ["size", "strokeWidth", "class"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<EditIcon> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("strokeWidth" in $$props) $$invalidate(1, strokeWidth = $$props.strokeWidth);
		if ("class" in $$props) $$invalidate(2, customClass = $$props.class);
	};

	$$self.$capture_state = () => ({ size, strokeWidth, customClass });

	$$self.$inject_state = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("strokeWidth" in $$props) $$invalidate(1, strokeWidth = $$props.strokeWidth);
		if ("customClass" in $$props) $$invalidate(2, customClass = $$props.customClass);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [size, strokeWidth, customClass];
}

class EditIcon extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$c, create_fragment$c, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "EditIcon",
			options,
			id: create_fragment$c.name
		});
	}

	get size() {
		throw new Error("<EditIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<EditIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get strokeWidth() {
		throw new Error("<EditIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set strokeWidth(value) {
		throw new Error("<EditIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<EditIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<EditIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\svelte-feather-icons\src\icons\Trash2Icon.svelte generated by Svelte v3.36.0 */

const file$b = "node_modules\\svelte-feather-icons\\src\\icons\\Trash2Icon.svelte";

function create_fragment$b(ctx) {
	let svg;
	let polyline;
	let path;
	let line0;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			path = svg_element("path");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			svg = claim_element(
				nodes,
				"svg",
				{
					xmlns: true,
					width: true,
					height: true,
					fill: true,
					viewBox: true,
					stroke: true,
					"stroke-width": true,
					"stroke-linecap": true,
					"stroke-linejoin": true,
					class: true
				},
				1
			);

			var svg_nodes = children(svg);
			polyline = claim_element(svg_nodes, "polyline", { points: true }, 1);
			children(polyline).forEach(detach_dev);
			path = claim_element(svg_nodes, "path", { d: true }, 1);
			children(path).forEach(detach_dev);
			line0 = claim_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, 1);
			children(line0).forEach(detach_dev);
			line1 = claim_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, 1);
			children(line1).forEach(detach_dev);
			svg_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline, "points", "3 6 5 6 21 6");
			add_location(polyline, file$b, 13, 244, 530);
			attr_dev(path, "d", "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2");
			add_location(path, file$b, 13, 287, 573);
			attr_dev(line0, "x1", "10");
			attr_dev(line0, "y1", "11");
			attr_dev(line0, "x2", "10");
			attr_dev(line0, "y2", "17");
			add_location(line0, file$b, 13, 383, 669);
			attr_dev(line1, "x1", "14");
			attr_dev(line1, "y1", "11");
			attr_dev(line1, "x2", "14");
			attr_dev(line1, "y2", "17");
			add_location(line1, file$b, 13, 428, 714);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "width", /*size*/ ctx[0]);
			attr_dev(svg, "height", /*size*/ ctx[0]);
			attr_dev(svg, "fill", "none");
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "stroke", "currentColor");
			attr_dev(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			attr_dev(svg, "stroke-linecap", "round");
			attr_dev(svg, "stroke-linejoin", "round");
			attr_dev(svg, "class", svg_class_value = "feather feather-trash-2 " + /*customClass*/ ctx[2]);
			add_location(svg, file$b, 13, 0, 286);
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline);
			append_dev(svg, path);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size*/ 1) {
				attr_dev(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr_dev(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*strokeWidth*/ 2) {
				attr_dev(svg, "stroke-width", /*strokeWidth*/ ctx[1]);
			}

			if (dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "feather feather-trash-2 " + /*customClass*/ ctx[2])) {
				attr_dev(svg, "class", svg_class_value);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$b($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Trash2Icon", slots, []);
	let { size = "100%" } = $$props;
	let { strokeWidth = 2 } = $$props;
	let { class: customClass = "" } = $$props;

	if (size !== "100%") {
		size = size.slice(-1) === "x"
		? size.slice(0, size.length - 1) + "em"
		: parseInt(size) + "px";
	}

	const writable_props = ["size", "strokeWidth", "class"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Trash2Icon> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("strokeWidth" in $$props) $$invalidate(1, strokeWidth = $$props.strokeWidth);
		if ("class" in $$props) $$invalidate(2, customClass = $$props.class);
	};

	$$self.$capture_state = () => ({ size, strokeWidth, customClass });

	$$self.$inject_state = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("strokeWidth" in $$props) $$invalidate(1, strokeWidth = $$props.strokeWidth);
		if ("customClass" in $$props) $$invalidate(2, customClass = $$props.customClass);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [size, strokeWidth, customClass];
}

class Trash2Icon extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$b, create_fragment$b, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Trash2Icon",
			options,
			id: create_fragment$b.name
		});
	}

	get size() {
		throw new Error("<Trash2Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Trash2Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get strokeWidth() {
		throw new Error("<Trash2Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set strokeWidth(value) {
		throw new Error("<Trash2Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Trash2Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Trash2Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const createOptions = () => {
    const {subscribe, set } = writable({
        sortable: true,
        pagination: true,
        rowPerPage: 50,
        columnFilter: false,
        scrollY: true,
        css: true,
        labels: {
            search: 'Search...',
            filter: 'Filter',
            noRows: 'No entries to found',
            info: 'Showing {start} to {end} of {rows} entries',
            previous: 'Previous',
            next: 'Next',
        },
        blocks: {
            searchInput: true, 
            paginationButtons: true,
            paginationRowCount: true,
        }
    });
    return {
        subscribe, set, 
        get: () => {
            let $store;
            options.subscribe(store => $store = store);
            return $store
        },
        update: (opt) => {
            opt.labels = opt.labels ? opt.labels : {};
            const labels = {
                search:   typeof opt.labels.search   === 'string' ? opt.labels.search   : 'Search...',
                filter:   typeof opt.labels.filter   === 'string' ? opt.labels.filter   : 'Filter',
                noRows:   typeof opt.labels.noRows   === 'string' ? opt.labels.noRows   : 'No entries to found',
                info:     typeof opt.labels.info     === 'string' ? opt.labels.info     : 'Showing {start} to {end} of {rows} entries',
                previous: typeof opt.labels.previous === 'string' ? opt.labels.previous : 'Previous',
                next:     typeof opt.labels.next     === 'string' ? opt.labels.next     : 'Next',                
            };   
            opt.blocks = opt.blocks ? opt.blocks : {};
            const blocks = {
                searchInput:        typeof opt.blocks.searchInput        === 'boolean' ? opt.blocks.searchInput        : true, 
                paginationButtons:  typeof opt.blocks.paginationButtons  === 'boolean' ? opt.blocks.paginationButtons  : true,
                paginationRowCount: typeof opt.blocks.paginationRowCount === 'boolean' ? opt.blocks.paginationRowCount : true,
            };
            const parsed = {
                sortable:     typeof opt.sortable     === 'boolean' ? opt.sortable     : true,
                pagination:   typeof opt.pagination   === 'boolean' ? opt.pagination   : true,
                rowPerPage:   typeof opt.rowPerPage   === 'number'  ? opt.rowPerPage   : 50,
                columnFilter: typeof opt.columnFilter === 'boolean' ? opt.columnFilter : false, 
                scrollY:      typeof opt.scrollY      === 'boolean' ? opt.scrollY      : true, 
                css:          typeof opt.css          === 'boolean' ? opt.css          : true, 
                labels: labels,
                blocks: blocks
            };
            options.set(parsed);
        }
    }
};
const options = createOptions();

const rowCount = writable(0);

const createPageNumber = () => {
	const { subscribe, update } = writable(1);
	return {
		subscribe, update,
		set: (number) => update(store => {
			let $rowPerPage, $rowCount;
			rowCount.subscribe(store => $rowCount = store);
			options.subscribe(store => $rowPerPage = store.rowPerPage);
			if ( number >= 1 && number <= Math.ceil($rowCount / $rowPerPage) ) {
				store = parseInt(number);
			}
			document.querySelector('section.datatable .dt-table').scrollTop = 0;
			return store
		})
	}
};
const pageNumber = createPageNumber();

const datatableWidth = writable(null);

const createLocal = () => {
	const { subscribe, update } = writable([]);
	return {
		subscribe, update,
		add: (key, value) => update(store => {
			const filter = {key: key, value: value}; 
			store = store.filter(item => { return item.key !== key && item.value.length > 0 });
			store.push(filter);
			return store
		}),
		remove: () => update(store => [])
	}
};
const local = createLocal();

const createGlobal = () => {
	const { subscribe, update } = writable(null);
	return {
		subscribe, 
		set: (value) => update(store => {
			store = (value.length > 0) ? value : null;
			return store
		}),
		remove: () => update(store => null)
	}
};
const global = createGlobal();

const createData = () => {
	const { subscribe, set, update } = writable([]);
	return {
		subscribe, set,
		sortAsc: (key) => update(store => {
			try {
				store.sort( (a, b) => key(b).localeCompare(key(a)) );
			} catch (e) {
				return store.sort( (a, b) => parseFloat(key(b)) - parseFloat(key(a)))
			}
			return store.sort( (a, b) => key(b).localeCompare(key(a)) )
			
		}),
		sortDesc: (key) => update(store => {
			try {
				store.sort( (a, b) => key(a).localeCompare(key(b)) );
			} catch (e) {
				return store.sort( (a, b) => parseFloat(key(a)) - parseFloat(key(b)))
			}
			return store.sort( (a, b) => key(a).localeCompare(key(b)) )
		}),
	}
};
const data = createData();

const filtered = derived(
	[data, global, local],
    ([$data, $global, $local]) => {
		if ($global) {
			$data = $data.filter( item => {
				return Object.keys(item).some( k => {
					return item[k].toString().toLowerCase().indexOf($global.toString().toLowerCase()) > -1
				})
			});
		}
		if ($local.length > 0) {
			$local.forEach(filter => {
				return $data = $data.filter( item => filter.key(item).toString().toLowerCase().indexOf(filter.value.toString().toLowerCase()) > -1)
			});
		}
		rowCount.set($data.length);
		return $data
	} 	
);

const rows = derived(
	[filtered, options, pageNumber],
    ([$filtered, $options, $pageNumber]) => {
		if (!$options.pagination) {
			return $filtered
		}
		return $filtered.slice( ($pageNumber - 1) * $options.rowPerPage, $pageNumber * $options.rowPerPage) 
	} 
);

const createColumns = () => {
	const { subscribe, set, update } = writable([]);
	return {
		subscribe, set, update,
		get: () => {
			let $columns;
			columns.subscribe(store => $columns = store);
			return $columns
		},
		sort: (element, key) => {
			if (options.get().sortable !== true || typeof key === 'undefined') {
				return
			}
			if (
				element.classList.contains('sortable') &&
				element.classList.contains('asc')
			) {
				Array.from(element.parentNode.children).forEach((item) =>
					item.classList.remove('asc', 'desc')
				);
				element.classList.add('desc');
				data.sortDesc(key);
				pageNumber.set(1);
			} else {
				Array.from(element.parentNode.children).forEach((item) =>
					item.classList.remove('desc', 'asc')
				);
				element.classList.add('asc');
				data.sortAsc(key);
				pageNumber.set(1);
			}
			columns.redraw();
		},
		filter: (key, value) => {
			pageNumber.set(1);
			local.add(key, value);
			columns.redraw();
		},
		draw: () => {
			setTimeout(() => {
				const tbody = document.querySelector('.datatable table tbody tr');
				if (tbody === null) return
				const thead = document.querySelectorAll('.dt-header thead tr');
				const $columns = columns.get();
				thead.forEach(tr => {
					let i = 0;
					Array.from(tbody.children).forEach(td => {
						let th = tr.children[i];
						let thW = th.getBoundingClientRect().width;
						let tdW = td.getBoundingClientRect().width;
						// let columnMinWidth = parseFloat(columns.get()[i].minWidth.replace('px', ''))
						if (tdW > thW) { 
							th.style.minWidth = tdW + 'px';
							th.style.maxWidth = tdW + 'px';
							$columns[i].minWidth = tdW;
						}
						else {
							td.style.minWidth = thW + 'px';
							td.style.maxWidth = thW + 'px';
							$columns[i].minWidth = thW;
						} 
						i++;
					});
				});
			}, 50);	
		},
		redraw: () => {
			if ( options.get().scrollY === false ) {
				return
			}
			setTimeout(() => {
				const tbody = document.querySelector('.datatable table tbody tr');
				if (tbody === null) return
				const thead = document.querySelectorAll('.dt-header thead tr');
				thead.forEach(tr => {
					let i = 0;
					Array.from(tbody.children).forEach(td => {
						let th = tr.children[i];
						let thW = th.getBoundingClientRect().width;
						let tdW = td.getBoundingClientRect().width;
						let columnMinWidth = parseFloat(columns.get()[i].minWidth);
						if (tdW > thW || thW > columnMinWidth) { 
							th.style.minWidth = tdW + 'px';
							th.style.maxWidth = tdW + 'px';
						}
						else {
							td.style.minWidth = thW + 'px';
							td.style.maxWidth = thW + 'px';
						} 
						i++;
					});
				});
			}, 50);			
		},
	}
};
const columns = createColumns();

const datatable = {
    init: () => {
        datatable.resize();
        datatable.addEventScrollX();
        datatable.getColumns();
        new ResizeObserver((mutations) => {
            datatable.resize();
        }).observe(document.querySelector('section.datatable').parentElement);
    },
    reset: () => {
        pageNumber.update(store => 1);
        global.remove();
        local.remove();
        columns.set([]);
    },
    setRows: (arr) => {
        arr.forEach( (item) => {
            Object.keys(item).forEach( (k) => {
                if (item[k] === null) {
                    item[k] = '';
                }
            });
        });
        data.set(arr);
        return
    },
    getSize: () => {
        const parent = document.querySelector('section.datatable').parentNode;
        const style = getComputedStyle(parent);
        const rect = parent.getBoundingClientRect();
        const getNumber = (pxValue) => { return parseFloat(pxValue.replace('px', ''))  }; 
        return {
            parentWidth: rect.width,
            parentHeight: rect.height,
            width: (rect.width - getNumber(style.paddingLeft) - getNumber(style.paddingRight) - getNumber(style.borderLeftWidth) - getNumber(style.borderRightWidth)) / rect.width,
            height: (rect.height - getNumber(style.paddingTop) - getNumber(style.paddingBottom) - getNumber(style.borderTopWidth) - getNumber(style.borderBottomWidth)) / rect.height,
            top: style.paddingTop,
            right: style.paddingRight,
            bottom: style.paddingBottom,
            left: style.paddingLeft
        }
    },
    resize: () => {
        if ( !document.querySelector('section.datatable') ) return
        const size = datatable.getSize();
        const tableContainer = document.querySelector('section.datatable .dt-table');
        if ( options.get().scrollY ) {
            tableContainer.style.height = datatable.getTableContainerHeight(size.parentHeight * size.height) + 'px';
            columns.redraw();
        }
        datatableWidth.set( size.parentWidth * size.width );
        if (size.parentWidth * size.width < document.querySelector('section.datatable table').offsetWidth) {
            tableContainer.style.overflowX = 'auto';
        }
    },
    getTableContainerHeight: (height) => {
        let paginationBlock;
        if (options.get().pagination && (options.get().blocks.paginationButtons || options.get().blocks.paginationRowCount)) {
            paginationBlock = true;
        }
        const calc = [
            (options.get().blocks.searchInput) ? document.querySelector('.datatable .dt-search').getBoundingClientRect().height : 0,
            (paginationBlock) ? document.querySelector('.datatable .dt-pagination').getBoundingClientRect().height : 0
        ];
        const sum = (a, b) => a + b;
        document.querySelector('section.datatable .dt-table').style.height = height - calc.reduce(sum) + 'px';
    },
    addEventScrollX: () => {
        if ( options.get().scrollY ) {
            document.querySelector('section.datatable .dt-table').addEventListener('scroll', (e) => {
                document.querySelector('.dt-header').style.left = (-1 * e.target.scrollLeft) + 'px';
            });
        }
    },
    getColumns: () => {
        const columnList = [];
        let i = 0;
        document.querySelectorAll('.datatable table thead th').forEach(th => {
            columnList.push({
                index: i,
                html: th.innerHTML,
                key: datatable.getKey(th.dataset.key),
                sort: null,
                classList: th.classList,
                minWidth: th.getBoundingClientRect().width
            });
            th.addEventListener('click', (e) => {
                columns.sort(e.target, datatable.getKey(th.dataset.key));
            }, true);
            i++;
        });
        columns.set(columnList);
    },
    getKey: (key) => {
        if (!key)  return 
        if (key && key.indexOf('=>') > 0) {
            return new Function(`'use strict';return (${key})`)()
        }
        return (x) => x[key]
    },
};

/* node_modules\svelte-simple-datatables\src\SearchInput.svelte generated by Svelte v3.36.0 */
const file$a = "node_modules\\svelte-simple-datatables\\src\\SearchInput.svelte";

function create_fragment$a(ctx) {
	let input;
	let input_class_value;
	let input_placeholder_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			input = claim_element(nodes, "INPUT", {
				class: true,
				type: true,
				placeholder: true,
				ref: true
			});

			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "class", input_class_value = "" + (null_to_empty(/*classList*/ ctx[1]) + " svelte-1kn6xvh"));
			attr_dev(input, "type", "text");
			attr_dev(input, "placeholder", input_placeholder_value = /*$options*/ ctx[2].labels.search);
			attr_dev(input, "ref", /*ref*/ ctx[0]);
			toggle_class(input, "css", /*$options*/ ctx[2].css);
			add_location(input, file$a, 14, 0, 403);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);

			if (!mounted) {
				dispose = listen_dev(input, "input", /*input_handler*/ ctx[4], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*classList*/ 2 && input_class_value !== (input_class_value = "" + (null_to_empty(/*classList*/ ctx[1]) + " svelte-1kn6xvh"))) {
				attr_dev(input, "class", input_class_value);
			}

			if (dirty & /*$options*/ 4 && input_placeholder_value !== (input_placeholder_value = /*$options*/ ctx[2].labels.search)) {
				attr_dev(input, "placeholder", input_placeholder_value);
			}

			if (dirty & /*ref*/ 1) {
				attr_dev(input, "ref", /*ref*/ ctx[0]);
			}

			if (dirty & /*classList, $options*/ 6) {
				toggle_class(input, "css", /*$options*/ ctx[2].css);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$a($$self, $$props, $$invalidate) {
	let $options;
	validate_store(options, "options");
	component_subscribe($$self, options, $$value => $$invalidate(2, $options = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("SearchInput", slots, []);
	let { ref = "" } = $$props;
	let { classList = "" } = $$props;

	const search = value => {
		pageNumber.set(1);
		global.set(value);
		columns.redraw();
	};

	const writable_props = ["ref", "classList"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SearchInput> was created with unknown prop '${key}'`);
	});

	const input_handler = e => search(e.target.value);

	$$self.$$set = $$props => {
		if ("ref" in $$props) $$invalidate(0, ref = $$props.ref);
		if ("classList" in $$props) $$invalidate(1, classList = $$props.classList);
	};

	$$self.$capture_state = () => ({
		options,
		pageNumber,
		columns,
		global,
		ref,
		classList,
		search,
		$options
	});

	$$self.$inject_state = $$props => {
		if ("ref" in $$props) $$invalidate(0, ref = $$props.ref);
		if ("classList" in $$props) $$invalidate(1, classList = $$props.classList);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [ref, classList, $options, search, input_handler];
}

class SearchInput extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$a, create_fragment$a, safe_not_equal, { ref: 0, classList: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "SearchInput",
			options,
			id: create_fragment$a.name
		});
	}

	get ref() {
		throw new Error("<SearchInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ref(value) {
		throw new Error("<SearchInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get classList() {
		throw new Error("<SearchInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set classList(value) {
		throw new Error("<SearchInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\svelte-simple-datatables\src\components\Search.svelte generated by Svelte v3.36.0 */
const file$9 = "node_modules\\svelte-simple-datatables\\src\\components\\Search.svelte";

function create_fragment$9(ctx) {
	let section;
	let searchinput;
	let current;
	searchinput = new SearchInput({ $$inline: true });

	const block = {
		c: function create() {
			section = element("section");
			create_component(searchinput.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			claim_component(searchinput.$$.fragment, section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(section, "class", "dt-search svelte-11nchoy");
			toggle_class(section, "css", /*$options*/ ctx[0].css);
			add_location(section, file$9, 5, 0, 128);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			mount_component(searchinput, section, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*$options*/ 1) {
				toggle_class(section, "css", /*$options*/ ctx[0].css);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(searchinput.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(searchinput.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(searchinput);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$9.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$9($$self, $$props, $$invalidate) {
	let $options;
	validate_store(options, "options");
	component_subscribe($$self, options, $$value => $$invalidate(0, $options = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Search", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Search> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({ SearchInput, options, $options });
	return [$options];
}

class Search extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$9, create_fragment$9, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Search",
			options,
			id: create_fragment$9.name
		});
	}
}

/* node_modules\svelte-simple-datatables\src\PaginationRowCount.svelte generated by Svelte v3.36.0 */
const file$8 = "node_modules\\svelte-simple-datatables\\src\\PaginationRowCount.svelte";

// (19:4) {:else}
function create_else_block_1(ctx) {
	let html_tag;
	let raw_value = `<b>${/*start*/ ctx[0]}</b>-<b>${/*end*/ ctx[2]}</b>/<b>${/*rows*/ ctx[3]}</b>` + "";
	let html_anchor;

	const block = {
		c: function create() {
			html_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			html_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			html_tag = new HtmlTag(html_anchor);
		},
		m: function mount(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert_dev(target, html_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*start, end, rows*/ 13 && raw_value !== (raw_value = `<b>${/*start*/ ctx[0]}</b>-<b>${/*end*/ ctx[2]}</b>/<b>${/*rows*/ ctx[3]}</b>` + "")) html_tag.p(raw_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(html_anchor);
			if (detaching) html_tag.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(19:4) {:else}",
		ctx
	});

	return block;
}

// (13:4) {#if $datatableWidth > 600}
function create_if_block$6(ctx) {
	let if_block_anchor;

	function select_block_type_1(ctx, dirty) {
		if (/*rows*/ ctx[3] > 0) return create_if_block_1$5;
		return create_else_block$4;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$6.name,
		type: "if",
		source: "(13:4) {#if $datatableWidth > 600}",
		ctx
	});

	return block;
}

// (16:8) {:else}
function create_else_block$4(ctx) {
	let html_tag;
	let raw_value = /*$options*/ ctx[1].labels.noRows + "";
	let html_anchor;

	const block = {
		c: function create() {
			html_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			html_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			html_tag = new HtmlTag(html_anchor);
		},
		m: function mount(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert_dev(target, html_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$options*/ 2 && raw_value !== (raw_value = /*$options*/ ctx[1].labels.noRows + "")) html_tag.p(raw_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(html_anchor);
			if (detaching) html_tag.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$4.name,
		type: "else",
		source: "(16:8) {:else}",
		ctx
	});

	return block;
}

// (14:8) {#if rows > 0}
function create_if_block_1$5(ctx) {
	let html_tag;
	let html_anchor;

	const block = {
		c: function create() {
			html_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			html_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			html_tag = new HtmlTag(html_anchor);
		},
		m: function mount(target, anchor) {
			html_tag.m(/*info*/ ctx[4], target, anchor);
			insert_dev(target, html_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*info*/ 16) html_tag.p(/*info*/ ctx[4]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(html_anchor);
			if (detaching) html_tag.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$5.name,
		type: "if",
		source: "(14:8) {#if rows > 0}",
		ctx
	});

	return block;
}

function create_fragment$8(ctx) {
	let aside;

	function select_block_type(ctx, dirty) {
		if (/*$datatableWidth*/ ctx[5] > 600) return create_if_block$6;
		return create_else_block_1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			aside = element("aside");
			if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			aside = claim_element(nodes, "ASIDE", { class: true });
			var aside_nodes = children(aside);
			if_block.l(aside_nodes);
			aside_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(aside, "class", "dt-pagination-rowcount svelte-jt0h2f");
			toggle_class(aside, "css", /*$options*/ ctx[1].css);
			add_location(aside, file$8, 11, 0, 470);
		},
		m: function mount(target, anchor) {
			insert_dev(target, aside, anchor);
			if_block.m(aside, null);
		},
		p: function update(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(aside, null);
				}
			}

			if (dirty & /*$options*/ 2) {
				toggle_class(aside, "css", /*$options*/ ctx[1].css);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(aside);
			if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$8($$self, $$props, $$invalidate) {
	let start;
	let end;
	let rows;
	let info;
	let $pageNumber;
	let $options;
	let $rowCount;
	let $datatableWidth;
	validate_store(pageNumber, "pageNumber");
	component_subscribe($$self, pageNumber, $$value => $$invalidate(6, $pageNumber = $$value));
	validate_store(options, "options");
	component_subscribe($$self, options, $$value => $$invalidate(1, $options = $$value));
	validate_store(rowCount, "rowCount");
	component_subscribe($$self, rowCount, $$value => $$invalidate(7, $rowCount = $$value));
	validate_store(datatableWidth, "datatableWidth");
	component_subscribe($$self, datatableWidth, $$value => $$invalidate(5, $datatableWidth = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("PaginationRowCount", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<PaginationRowCount> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		options,
		pageNumber,
		rowCount,
		datatableWidth,
		start,
		$pageNumber,
		$options,
		end,
		$rowCount,
		rows,
		info,
		$datatableWidth
	});

	$$self.$inject_state = $$props => {
		if ("start" in $$props) $$invalidate(0, start = $$props.start);
		if ("end" in $$props) $$invalidate(2, end = $$props.end);
		if ("rows" in $$props) $$invalidate(3, rows = $$props.rows);
		if ("info" in $$props) $$invalidate(4, info = $$props.info);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$pageNumber, $options*/ 66) {
			$$invalidate(0, start = $pageNumber * $options.rowPerPage - $options.rowPerPage + 1);
		}

		if ($$self.$$.dirty & /*$pageNumber, $options, $rowCount*/ 194) {
			$$invalidate(2, end = Math.min($pageNumber * $options.rowPerPage, $rowCount));
		}

		if ($$self.$$.dirty & /*$rowCount*/ 128) {
			$$invalidate(3, rows = $rowCount);
		}

		if ($$self.$$.dirty & /*$options, start, end, rows*/ 15) {
			$$invalidate(4, info = $options.labels.info.replace("{start}", `<b>${start}</b>`).replace("{end}", `<b>${end}</b>`).replace("{rows}", `<b>${rows}</b>`));
		}
	};

	return [start, $options, end, rows, info, $datatableWidth, $pageNumber, $rowCount];
}

class PaginationRowCount extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$8, create_fragment$8, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "PaginationRowCount",
			options,
			id: create_fragment$8.name
		});
	}
}

/* node_modules\svelte-simple-datatables\src\PaginationButtons.svelte generated by Svelte v3.36.0 */
const file$7 = "node_modules\\svelte-simple-datatables\\src\\PaginationButtons.svelte";

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[19] = list[i];
	return child_ctx;
}

// (70:0) {:else}
function create_else_block$3(ctx) {
	let section;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let t3;
	let button2;
	let t4;
	let t5;
	let button3;
	let t6;
	let section_class_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			section = element("section");
			button0 = element("button");
			t0 = text("❬❬");
			t1 = space();
			button1 = element("button");
			t2 = text("❮");
			t3 = space();
			button2 = element("button");
			t4 = text("❯");
			t5 = space();
			button3 = element("button");
			t6 = text("❭❭");
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			button0 = claim_element(section_nodes, "BUTTON", { class: true });
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "❬❬");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(section_nodes);
			button1 = claim_element(section_nodes, "BUTTON", { class: true });
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "❮");
			button1_nodes.forEach(detach_dev);
			t3 = claim_space(section_nodes);
			button2 = claim_element(section_nodes, "BUTTON", { class: true });
			var button2_nodes = children(button2);
			t4 = claim_text(button2_nodes, "❯");
			button2_nodes.forEach(detach_dev);
			t5 = claim_space(section_nodes);
			button3 = claim_element(section_nodes, "BUTTON", { class: true });
			var button3_nodes = children(button3);
			t6 = claim_text(button3_nodes, "❭❭");
			button3_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button0, "class", "svelte-9qvh1i");
			toggle_class(button0, "disabled", /*$pageNumber*/ ctx[4] === 1);
			add_location(button0, file$7, 71, 8, 2390);
			attr_dev(button1, "class", "svelte-9qvh1i");
			toggle_class(button1, "disabled", /*$pageNumber*/ ctx[4] === 1);
			add_location(button1, file$7, 72, 8, 2496);
			attr_dev(button2, "class", "svelte-9qvh1i");
			toggle_class(button2, "disabled", /*$pageNumber*/ ctx[4] === /*pageCount*/ ctx[2].length);
			add_location(button2, file$7, 73, 8, 2608);
			attr_dev(button3, "class", "svelte-9qvh1i");
			toggle_class(button3, "disabled", /*$pageNumber*/ ctx[4] === /*pageCount*/ ctx[2].length);
			add_location(button3, file$7, 74, 8, 2736);
			attr_dev(section, "class", section_class_value = "dt-pagination-buttons mobile " + /*classList*/ ctx[1] + " svelte-9qvh1i");
			toggle_class(section, "css", /*$options*/ ctx[3].css);
			add_location(section, file$7, 70, 4, 2297);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, button0);
			append_dev(button0, t0);
			append_dev(section, t1);
			append_dev(section, button1);
			append_dev(button1, t2);
			append_dev(section, t3);
			append_dev(section, button2);
			append_dev(button2, t4);
			append_dev(section, t5);
			append_dev(section, button3);
			append_dev(button3, t6);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*click_handler_5*/ ctx[14], false, false, false),
					listen_dev(button1, "click", /*click_handler_6*/ ctx[15], false, false, false),
					listen_dev(button2, "click", /*click_handler_7*/ ctx[16], false, false, false),
					listen_dev(button3, "click", /*click_handler_8*/ ctx[17], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$pageNumber*/ 16) {
				toggle_class(button0, "disabled", /*$pageNumber*/ ctx[4] === 1);
			}

			if (dirty & /*$pageNumber*/ 16) {
				toggle_class(button1, "disabled", /*$pageNumber*/ ctx[4] === 1);
			}

			if (dirty & /*$pageNumber, pageCount*/ 20) {
				toggle_class(button2, "disabled", /*$pageNumber*/ ctx[4] === /*pageCount*/ ctx[2].length);
			}

			if (dirty & /*$pageNumber, pageCount*/ 20) {
				toggle_class(button3, "disabled", /*$pageNumber*/ ctx[4] === /*pageCount*/ ctx[2].length);
			}

			if (dirty & /*classList*/ 2 && section_class_value !== (section_class_value = "dt-pagination-buttons mobile " + /*classList*/ ctx[1] + " svelte-9qvh1i")) {
				attr_dev(section, "class", section_class_value);
			}

			if (dirty & /*classList, $options*/ 10) {
				toggle_class(section, "css", /*$options*/ ctx[3].css);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$3.name,
		type: "else",
		source: "(70:0) {:else}",
		ctx
	});

	return block;
}

// (25:0) {#if $datatableWidth > 600}
function create_if_block$5(ctx) {
	let section;
	let button0;
	let raw0_value = /*$options*/ ctx[3].labels.previous + "";
	let t0;
	let button1;
	let t1;
	let t2;
	let t3;
	let t4;
	let t5;
	let t6;
	let button2;
	let raw1_value = /*$options*/ ctx[3].labels.next + "";
	let section_class_value;
	let mounted;
	let dispose;
	let if_block0 = /*pageCount*/ ctx[2].length > 6 && /*$pageNumber*/ ctx[4] >= 5 && create_if_block_4(ctx);
	let each_value = /*buttons*/ ctx[5];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	let if_block1 = /*pageCount*/ ctx[2].length > 6 && /*$pageNumber*/ ctx[4] <= /*pageCount*/ ctx[2].length - 3 && create_if_block_2$3(ctx);
	let if_block2 = /*pageCount*/ ctx[2].length > 1 && create_if_block_1$4(ctx);

	const block = {
		c: function create() {
			section = element("section");
			button0 = element("button");
			t0 = space();
			button1 = element("button");
			t1 = text("1");
			t2 = space();
			if (if_block0) if_block0.c();
			t3 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t4 = space();
			if (if_block1) if_block1.c();
			t5 = space();
			if (if_block2) if_block2.c();
			t6 = space();
			button2 = element("button");
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true, ref: true });
			var section_nodes = children(section);
			button0 = claim_element(section_nodes, "BUTTON", { class: true });
			var button0_nodes = children(button0);
			button0_nodes.forEach(detach_dev);
			t0 = claim_space(section_nodes);
			button1 = claim_element(section_nodes, "BUTTON", { class: true });
			var button1_nodes = children(button1);
			t1 = claim_text(button1_nodes, "1");
			button1_nodes.forEach(detach_dev);
			t2 = claim_space(section_nodes);
			if (if_block0) if_block0.l(section_nodes);
			t3 = claim_space(section_nodes);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(section_nodes);
			}

			t4 = claim_space(section_nodes);
			if (if_block1) if_block1.l(section_nodes);
			t5 = claim_space(section_nodes);
			if (if_block2) if_block2.l(section_nodes);
			t6 = claim_space(section_nodes);
			button2 = claim_element(section_nodes, "BUTTON", { class: true });
			var button2_nodes = children(button2);
			button2_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button0, "class", "text svelte-9qvh1i");
			toggle_class(button0, "disabled", /*$pageNumber*/ ctx[4] === 1);
			add_location(button0, file$7, 26, 8, 905);
			attr_dev(button1, "class", "svelte-9qvh1i");
			toggle_class(button1, "active", /*$pageNumber*/ ctx[4] === 1);
			add_location(button1, file$7, 33, 8, 1128);
			attr_dev(button2, "class", "text svelte-9qvh1i");
			toggle_class(button2, "disabled", /*$pageNumber*/ ctx[4] === /*pageCount*/ ctx[2].length);
			add_location(button2, file$7, 61, 8, 2042);
			attr_dev(section, "class", section_class_value = "dt-pagination-buttons " + /*classList*/ ctx[1] + " svelte-9qvh1i");
			attr_dev(section, "ref", /*ref*/ ctx[0]);
			toggle_class(section, "css", /*$options*/ ctx[3].css);
			add_location(section, file$7, 25, 4, 813);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, button0);
			button0.innerHTML = raw0_value;
			append_dev(section, t0);
			append_dev(section, button1);
			append_dev(button1, t1);
			append_dev(section, t2);
			if (if_block0) if_block0.m(section, null);
			append_dev(section, t3);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(section, null);
			}

			append_dev(section, t4);
			if (if_block1) if_block1.m(section, null);
			append_dev(section, t5);
			if (if_block2) if_block2.m(section, null);
			append_dev(section, t6);
			append_dev(section, button2);
			button2.innerHTML = raw1_value;

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*click_handler*/ ctx[9], false, false, false),
					listen_dev(button1, "click", /*click_handler_1*/ ctx[10], false, false, false),
					listen_dev(button2, "click", /*click_handler_4*/ ctx[13], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$options*/ 8 && raw0_value !== (raw0_value = /*$options*/ ctx[3].labels.previous + "")) button0.innerHTML = raw0_value;
			if (dirty & /*$pageNumber*/ 16) {
				toggle_class(button0, "disabled", /*$pageNumber*/ ctx[4] === 1);
			}

			if (dirty & /*$pageNumber*/ 16) {
				toggle_class(button1, "active", /*$pageNumber*/ ctx[4] === 1);
			}

			if (/*pageCount*/ ctx[2].length > 6 && /*$pageNumber*/ ctx[4] >= 5) {
				if (if_block0) ; else {
					if_block0 = create_if_block_4(ctx);
					if_block0.c();
					if_block0.m(section, t3);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*$pageNumber, buttons, setPage, pageCount*/ 180) {
				each_value = /*buttons*/ ctx[5];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(section, t4);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (/*pageCount*/ ctx[2].length > 6 && /*$pageNumber*/ ctx[4] <= /*pageCount*/ ctx[2].length - 3) {
				if (if_block1) ; else {
					if_block1 = create_if_block_2$3(ctx);
					if_block1.c();
					if_block1.m(section, t5);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*pageCount*/ ctx[2].length > 1) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_1$4(ctx);
					if_block2.c();
					if_block2.m(section, t6);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (dirty & /*$options*/ 8 && raw1_value !== (raw1_value = /*$options*/ ctx[3].labels.next + "")) button2.innerHTML = raw1_value;
			if (dirty & /*$pageNumber, pageCount*/ 20) {
				toggle_class(button2, "disabled", /*$pageNumber*/ ctx[4] === /*pageCount*/ ctx[2].length);
			}

			if (dirty & /*classList*/ 2 && section_class_value !== (section_class_value = "dt-pagination-buttons " + /*classList*/ ctx[1] + " svelte-9qvh1i")) {
				attr_dev(section, "class", section_class_value);
			}

			if (dirty & /*ref*/ 1) {
				attr_dev(section, "ref", /*ref*/ ctx[0]);
			}

			if (dirty & /*classList, $options*/ 10) {
				toggle_class(section, "css", /*$options*/ ctx[3].css);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			if (if_block0) if_block0.d();
			destroy_each(each_blocks, detaching);
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$5.name,
		type: "if",
		source: "(25:0) {#if $datatableWidth > 600}",
		ctx
	});

	return block;
}

// (37:8) {#if pageCount.length > 6 && $pageNumber >= 5}
function create_if_block_4(ctx) {
	let button;
	let t;

	const block = {
		c: function create() {
			button = element("button");
			t = text("...");
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			t = claim_text(button_nodes, "...");
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button, "class", "ellipse svelte-9qvh1i");
			add_location(button, file$7, 37, 12, 1303);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(37:8) {#if pageCount.length > 6 && $pageNumber >= 5}",
		ctx
	});

	return block;
}

// (42:12) {#if n > 0 && n < pageCount.length - 1}
function create_if_block_3(ctx) {
	let button;
	let t_value = /*n*/ ctx[19] + 1 + "";
	let t;
	let mounted;
	let dispose;

	function click_handler_2() {
		return /*click_handler_2*/ ctx[11](/*n*/ ctx[19]);
	}

	const block = {
		c: function create() {
			button = element("button");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			t = claim_text(button_nodes, t_value);
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button, "class", "svelte-9qvh1i");
			toggle_class(button, "active", /*$pageNumber*/ ctx[4] === /*n*/ ctx[19] + 1);
			add_location(button, file$7, 42, 12, 1453);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t);

			if (!mounted) {
				dispose = listen_dev(button, "click", click_handler_2, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*buttons*/ 32 && t_value !== (t_value = /*n*/ ctx[19] + 1 + "")) set_data_dev(t, t_value);

			if (dirty & /*$pageNumber, buttons*/ 48) {
				toggle_class(button, "active", /*$pageNumber*/ ctx[4] === /*n*/ ctx[19] + 1);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(42:12) {#if n > 0 && n < pageCount.length - 1}",
		ctx
	});

	return block;
}

// (41:8) {#each buttons as n}
function create_each_block$2(ctx) {
	let if_block_anchor;
	let if_block = /*n*/ ctx[19] > 0 && /*n*/ ctx[19] < /*pageCount*/ ctx[2].length - 1 && create_if_block_3(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (/*n*/ ctx[19] > 0 && /*n*/ ctx[19] < /*pageCount*/ ctx[2].length - 1) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_3(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$2.name,
		type: "each",
		source: "(41:8) {#each buttons as n}",
		ctx
	});

	return block;
}

// (52:8) {#if pageCount.length > 6 && $pageNumber <= pageCount.length - 3}
function create_if_block_2$3(ctx) {
	let button;
	let t;

	const block = {
		c: function create() {
			button = element("button");
			t = text("...");
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			t = claim_text(button_nodes, "...");
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button, "class", "ellipse svelte-9qvh1i");
			add_location(button, file$7, 52, 12, 1754);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$3.name,
		type: "if",
		source: "(52:8) {#if pageCount.length > 6 && $pageNumber <= pageCount.length - 3}",
		ctx
	});

	return block;
}

// (56:8) {#if pageCount.length > 1}
function create_if_block_1$4(ctx) {
	let button;
	let t_value = /*pageCount*/ ctx[2].length + "";
	let t;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			t = claim_text(button_nodes, t_value);
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button, "class", "svelte-9qvh1i");
			toggle_class(button, "active", /*$pageNumber*/ ctx[4] === /*pageCount*/ ctx[2].length);
			add_location(button, file$7, 56, 12, 1857);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*click_handler_3*/ ctx[12], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*pageCount*/ 4 && t_value !== (t_value = /*pageCount*/ ctx[2].length + "")) set_data_dev(t, t_value);

			if (dirty & /*$pageNumber, pageCount*/ 20) {
				toggle_class(button, "active", /*$pageNumber*/ ctx[4] === /*pageCount*/ ctx[2].length);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$4.name,
		type: "if",
		source: "(56:8) {#if pageCount.length > 1}",
		ctx
	});

	return block;
}

function create_fragment$7(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*$datatableWidth*/ ctx[6] > 600) return create_if_block$5;
		return create_else_block$3;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	let pageCount;
	let buttons;
	let $rowCount;
	let $options;
	let $pageNumber;
	let $datatableWidth;
	validate_store(rowCount, "rowCount");
	component_subscribe($$self, rowCount, $$value => $$invalidate(8, $rowCount = $$value));
	validate_store(options, "options");
	component_subscribe($$self, options, $$value => $$invalidate(3, $options = $$value));
	validate_store(pageNumber, "pageNumber");
	component_subscribe($$self, pageNumber, $$value => $$invalidate(4, $pageNumber = $$value));
	validate_store(datatableWidth, "datatableWidth");
	component_subscribe($$self, datatableWidth, $$value => $$invalidate(6, $datatableWidth = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("PaginationButtons", slots, []);
	let { ref = "" } = $$props;
	let { classList = "" } = $$props;

	const slice = (arr, page) => {
		if (page < 5) {
			return arr.slice(0, 5);
		} else if (page > arr.length - 4) {
			return arr.slice(arr.length - 5, arr.length);
		}

		return arr.slice(page - 2, page + 1);
	};

	const setPage = number => {
		pageNumber.set(number);
		columns.redraw();
	};

	const writable_props = ["ref", "classList"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<PaginationButtons> was created with unknown prop '${key}'`);
	});

	const click_handler = () => setPage($pageNumber - 1);
	const click_handler_1 = () => setPage(1);
	const click_handler_2 = n => setPage(n + 1);
	const click_handler_3 = () => setPage(pageCount.length);
	const click_handler_4 = () => setPage($pageNumber + 1);
	const click_handler_5 = () => setPage(1);
	const click_handler_6 = () => setPage($pageNumber - 1);
	const click_handler_7 = () => setPage($pageNumber + 1);
	const click_handler_8 = () => setPage(pageCount.length);

	$$self.$$set = $$props => {
		if ("ref" in $$props) $$invalidate(0, ref = $$props.ref);
		if ("classList" in $$props) $$invalidate(1, classList = $$props.classList);
	};

	$$self.$capture_state = () => ({
		options,
		rowCount,
		pageNumber,
		datatableWidth,
		columns,
		ref,
		classList,
		slice,
		setPage,
		pageCount,
		$rowCount,
		$options,
		buttons,
		$pageNumber,
		$datatableWidth
	});

	$$self.$inject_state = $$props => {
		if ("ref" in $$props) $$invalidate(0, ref = $$props.ref);
		if ("classList" in $$props) $$invalidate(1, classList = $$props.classList);
		if ("pageCount" in $$props) $$invalidate(2, pageCount = $$props.pageCount);
		if ("buttons" in $$props) $$invalidate(5, buttons = $$props.buttons);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$rowCount, $options*/ 264) {
			$$invalidate(2, pageCount = Array.from(Array(Math.ceil($rowCount / $options.rowPerPage)).keys()));
		}

		if ($$self.$$.dirty & /*pageCount, $pageNumber*/ 20) {
			$$invalidate(5, buttons = slice(pageCount, $pageNumber));
		}
	};

	return [
		ref,
		classList,
		pageCount,
		$options,
		$pageNumber,
		buttons,
		$datatableWidth,
		setPage,
		$rowCount,
		click_handler,
		click_handler_1,
		click_handler_2,
		click_handler_3,
		click_handler_4,
		click_handler_5,
		click_handler_6,
		click_handler_7,
		click_handler_8
	];
}

class PaginationButtons extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$7, create_fragment$7, safe_not_equal, { ref: 0, classList: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "PaginationButtons",
			options,
			id: create_fragment$7.name
		});
	}

	get ref() {
		throw new Error("<PaginationButtons>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ref(value) {
		throw new Error("<PaginationButtons>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get classList() {
		throw new Error("<PaginationButtons>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set classList(value) {
		throw new Error("<PaginationButtons>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\svelte-simple-datatables\src\components\Pagination.svelte generated by Svelte v3.36.0 */
const file$6 = "node_modules\\svelte-simple-datatables\\src\\components\\Pagination.svelte";

// (7:0) {#if $options.pagination && ($options.blocks.paginationRowCount || $options.blocks.paginationButtons)}
function create_if_block$4(ctx) {
	let section;
	let current_block_type_index;
	let if_block0;
	let t;
	let current;
	const if_block_creators = [create_if_block_2$2, create_else_block$2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*$options*/ ctx[0].blocks.paginationRowCount) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let if_block1 = /*$options*/ ctx[0].blocks.paginationButtons && create_if_block_1$3(ctx);

	const block = {
		c: function create() {
			section = element("section");
			if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			if_block0.l(section_nodes);
			t = claim_space(section_nodes);
			if (if_block1) if_block1.l(section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(section, "class", "dt-pagination svelte-195bjyp");
			toggle_class(section, "css", /*$options*/ ctx[0].css);
			add_location(section, file$6, 7, 4, 315);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			if_blocks[current_block_type_index].m(section, null);
			append_dev(section, t);
			if (if_block1) if_block1.m(section, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index !== previous_block_index) {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				}

				transition_in(if_block0, 1);
				if_block0.m(section, t);
			}

			if (/*$options*/ ctx[0].blocks.paginationButtons) {
				if (if_block1) {
					if (dirty & /*$options*/ 1) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$3(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(section, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (dirty & /*$options*/ 1) {
				toggle_class(section, "css", /*$options*/ ctx[0].css);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			if_blocks[current_block_type_index].d();
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$4.name,
		type: "if",
		source: "(7:0) {#if $options.pagination && ($options.blocks.paginationRowCount || $options.blocks.paginationButtons)}",
		ctx
	});

	return block;
}

// (11:8) {:else}
function create_else_block$2(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {});
			children(div).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(div, file$6, 11, 12, 488);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$2.name,
		type: "else",
		source: "(11:8) {:else}",
		ctx
	});

	return block;
}

// (9:8) {#if $options.blocks.paginationRowCount}
function create_if_block_2$2(ctx) {
	let paginationrowcount;
	let current;
	paginationrowcount = new PaginationRowCount({ $$inline: true });

	const block = {
		c: function create() {
			create_component(paginationrowcount.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(paginationrowcount.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(paginationrowcount, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(paginationrowcount.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(paginationrowcount.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(paginationrowcount, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$2.name,
		type: "if",
		source: "(9:8) {#if $options.blocks.paginationRowCount}",
		ctx
	});

	return block;
}

// (14:8) {#if $options.blocks.paginationButtons}
function create_if_block_1$3(ctx) {
	let paginationbuttons;
	let current;
	paginationbuttons = new PaginationButtons({ $$inline: true });

	const block = {
		c: function create() {
			create_component(paginationbuttons.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(paginationbuttons.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(paginationbuttons, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(paginationbuttons.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(paginationbuttons.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(paginationbuttons, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$3.name,
		type: "if",
		source: "(14:8) {#if $options.blocks.paginationButtons}",
		ctx
	});

	return block;
}

function create_fragment$6(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*$options*/ ctx[0].pagination && (/*$options*/ ctx[0].blocks.paginationRowCount || /*$options*/ ctx[0].blocks.paginationButtons) && create_if_block$4(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*$options*/ ctx[0].pagination && (/*$options*/ ctx[0].blocks.paginationRowCount || /*$options*/ ctx[0].blocks.paginationButtons)) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*$options*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$4(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	let $options;
	validate_store(options, "options");
	component_subscribe($$self, options, $$value => $$invalidate(0, $options = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Pagination", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Pagination> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		PaginationRowCount,
		PaginationButtons,
		options,
		$options
	});

	return [$options];
}

class Pagination extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Pagination",
			options,
			id: create_fragment$6.name
		});
	}
}

const header = {
    removeOriginalThead: () => {
        setTimeout(() => {
            const thead = document.querySelector('.datatable table thead');
            const originHeight = thead.getBoundingClientRect().height;
            // const tableContainer = document.querySelector('section.datatable .dt-table')
            // const scrollXHeight = tableContainer.offsetHeight - tableContainer.clientHeight
            // - (scrollXHeight > 5 ? scrollXHeight + 10 : 1)
            thead.parentNode.style.marginTop = '-' + (originHeight) + 'px';
            thead.style.visibility = 'hidden';
        }, 50);
    },
    getOrginalTHeadClassList: () => {
        return document.querySelector('.datatable table thead').classList
    },
};

/* node_modules\svelte-simple-datatables\src\components\StickyHeader.svelte generated by Svelte v3.36.0 */
const file$5 = "node_modules\\svelte-simple-datatables\\src\\components\\StickyHeader.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i];
	return child_ctx;
}

// (17:12) {#each $columns as th}
function create_each_block_1(ctx) {
	let th;
	let html_tag;
	let raw_value = /*th*/ ctx[5].html + "";
	let span;
	let t;
	let th_class_value;
	let mounted;
	let dispose;

	function click_handler(...args) {
		return /*click_handler*/ ctx[3](/*th*/ ctx[5], ...args);
	}

	const block = {
		c: function create() {
			th = element("th");
			span = element("span");
			t = space();
			this.h();
		},
		l: function claim(nodes) {
			th = claim_element(nodes, "TH", { nowrap: true, style: true, class: true });
			var th_nodes = children(th);
			span = claim_element(th_nodes, "SPAN", { class: true });
			children(span).forEach(detach_dev);
			t = claim_space(th_nodes);
			th_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			html_tag = new HtmlTag(span);
			attr_dev(span, "class", "svelte-1sonwgi");
			add_location(span, file$5, 24, 35, 911);
			attr_dev(th, "nowrap", "");
			set_style(th, "min-width", /*th*/ ctx[5].minWidth + "px");
			attr_dev(th, "class", th_class_value = "" + (null_to_empty(/*th*/ ctx[5].classList) + " svelte-1sonwgi"));
			toggle_class(th, "sortable", /*th*/ ctx[5].key && /*$options*/ ctx[1].sortable === true);
			add_location(th, file$5, 17, 16, 582);
		},
		m: function mount(target, anchor) {
			insert_dev(target, th, anchor);
			html_tag.m(raw_value, th);
			append_dev(th, span);
			append_dev(th, t);

			if (!mounted) {
				dispose = listen_dev(th, "click", click_handler, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*$columns*/ 4 && raw_value !== (raw_value = /*th*/ ctx[5].html + "")) html_tag.p(raw_value);

			if (dirty & /*$columns*/ 4) {
				set_style(th, "min-width", /*th*/ ctx[5].minWidth + "px");
			}

			if (dirty & /*$columns*/ 4 && th_class_value !== (th_class_value = "" + (null_to_empty(/*th*/ ctx[5].classList) + " svelte-1sonwgi"))) {
				attr_dev(th, "class", th_class_value);
			}

			if (dirty & /*$columns, $columns, $options*/ 6) {
				toggle_class(th, "sortable", /*th*/ ctx[5].key && /*$options*/ ctx[1].sortable === true);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(th);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(17:12) {#each $columns as th}",
		ctx
	});

	return block;
}

// (29:8) {#if $options.columnFilter === true}
function create_if_block$3(ctx) {
	let tr;
	let each_value = /*$columns*/ ctx[2];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			tr = element("tr");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			tr = claim_element(nodes, "TR", {});
			var tr_nodes = children(tr);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(tr_nodes);
			}

			tr_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(tr, file$5, 29, 12, 1038);
		},
		m: function mount(target, anchor) {
			insert_dev(target, tr, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tr, null);
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$columns, $options, columns*/ 6) {
				each_value = /*$columns*/ ctx[2];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(tr, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tr);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$3.name,
		type: "if",
		source: "(29:8) {#if $options.columnFilter === true}",
		ctx
	});

	return block;
}

// (33:24) {#if th.key}
function create_if_block_1$2(ctx) {
	let input;
	let input_placeholder_value;
	let mounted;
	let dispose;

	function input_handler(...args) {
		return /*input_handler*/ ctx[4](/*th*/ ctx[5], ...args);
	}

	const block = {
		c: function create() {
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			input = claim_element(nodes, "INPUT", {
				type: true,
				placeholder: true,
				class: true
			});

			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "type", "text");
			attr_dev(input, "placeholder", input_placeholder_value = /*$options*/ ctx[1].labels.filter);
			attr_dev(input, "class", "browser-default svelte-1sonwgi");
			add_location(input, file$5, 33, 28, 1229);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);

			if (!mounted) {
				dispose = listen_dev(input, "input", input_handler, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*$options*/ 2 && input_placeholder_value !== (input_placeholder_value = /*$options*/ ctx[1].labels.filter)) {
				attr_dev(input, "placeholder", input_placeholder_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$2.name,
		type: "if",
		source: "(33:24) {#if th.key}",
		ctx
	});

	return block;
}

// (31:16) {#each $columns as th}
function create_each_block$1(ctx) {
	let th;
	let t;
	let if_block = /*th*/ ctx[5].key && create_if_block_1$2(ctx);

	const block = {
		c: function create() {
			th = element("th");
			if (if_block) if_block.c();
			t = space();
			this.h();
		},
		l: function claim(nodes) {
			th = claim_element(nodes, "TH", { class: true, style: true });
			var th_nodes = children(th);
			if (if_block) if_block.l(th_nodes);
			t = claim_space(th_nodes);
			th_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(th, "class", "filter svelte-1sonwgi");
			set_style(th, "width", /*th*/ ctx[5].width);
			set_style(th, "height", "25px");
			add_location(th, file$5, 31, 20, 1104);
		},
		m: function mount(target, anchor) {
			insert_dev(target, th, anchor);
			if (if_block) if_block.m(th, null);
			append_dev(th, t);
		},
		p: function update(ctx, dirty) {
			if (/*th*/ ctx[5].key) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$2(ctx);
					if_block.c();
					if_block.m(th, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*$columns*/ 4) {
				set_style(th, "width", /*th*/ ctx[5].width);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(th);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(31:16) {#each $columns as th}",
		ctx
	});

	return block;
}

function create_fragment$5(ctx) {
	let section;
	let thead;
	let tr;
	let t;
	let thead_class_value;
	let each_value_1 = /*$columns*/ ctx[2];
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	let if_block = /*$options*/ ctx[1].columnFilter === true && create_if_block$3(ctx);

	const block = {
		c: function create() {
			section = element("section");
			thead = element("thead");
			tr = element("tr");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			thead = claim_element(section_nodes, "THEAD", { class: true });
			var thead_nodes = children(thead);
			tr = claim_element(thead_nodes, "TR", {});
			var tr_nodes = children(tr);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(tr_nodes);
			}

			tr_nodes.forEach(detach_dev);
			t = claim_space(thead_nodes);
			if (if_block) if_block.l(thead_nodes);
			thead_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(tr, file$5, 15, 8, 524);
			attr_dev(thead, "class", thead_class_value = "" + (null_to_empty(/*theadClassList*/ ctx[0]) + " svelte-1sonwgi"));
			add_location(thead, file$5, 14, 4, 484);
			attr_dev(section, "class", "dt-header svelte-1sonwgi");
			toggle_class(section, "sortable", /*$options*/ ctx[1].sortable === true);
			toggle_class(section, "css", /*$options*/ ctx[1].css);
			add_location(section, file$5, 13, 0, 382);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, thead);
			append_dev(thead, tr);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tr, null);
			}

			append_dev(thead, t);
			if (if_block) if_block.m(thead, null);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*$columns, $options, columns*/ 6) {
				each_value_1 = /*$columns*/ ctx[2];
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(tr, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}

			if (/*$options*/ ctx[1].columnFilter === true) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$3(ctx);
					if_block.c();
					if_block.m(thead, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*theadClassList*/ 1 && thead_class_value !== (thead_class_value = "" + (null_to_empty(/*theadClassList*/ ctx[0]) + " svelte-1sonwgi"))) {
				attr_dev(thead, "class", thead_class_value);
			}

			if (dirty & /*$options*/ 2) {
				toggle_class(section, "sortable", /*$options*/ ctx[1].sortable === true);
			}

			if (dirty & /*$options*/ 2) {
				toggle_class(section, "css", /*$options*/ ctx[1].css);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_each(each_blocks, detaching);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	let $options;
	let $columns;
	validate_store(options, "options");
	component_subscribe($$self, options, $$value => $$invalidate(1, $options = $$value));
	validate_store(columns, "columns");
	component_subscribe($$self, columns, $$value => $$invalidate(2, $columns = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("StickyHeader", slots, []);
	let theadClassList;

	onMount(() => {
		columns.draw();
		header.removeOriginalThead();
		$$invalidate(0, theadClassList = header.getOrginalTHeadClassList());
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<StickyHeader> was created with unknown prop '${key}'`);
	});

	const click_handler = (th, e) => columns.sort(e.target, th.key);
	const input_handler = (th, e) => columns.filter(th.key, e.target.value);

	$$self.$capture_state = () => ({
		options,
		columns,
		header,
		onMount,
		theadClassList,
		$options,
		$columns
	});

	$$self.$inject_state = $$props => {
		if ("theadClassList" in $$props) $$invalidate(0, theadClassList = $$props.theadClassList);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [theadClassList, $options, $columns, click_handler, input_handler];
}

class StickyHeader extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "StickyHeader",
			options,
			id: create_fragment$5.name
		});
	}
}

/* node_modules\svelte-simple-datatables\src\Datatable.svelte generated by Svelte v3.36.0 */
const file$4 = "node_modules\\svelte-simple-datatables\\src\\Datatable.svelte";

// (20:1) {#if $options.blocks.searchInput === true}
function create_if_block_2$1(ctx) {
	let search;
	let current;
	search = new Search({ $$inline: true });

	const block = {
		c: function create() {
			create_component(search.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(search.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(search, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(search.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(search.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(search, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$1.name,
		type: "if",
		source: "(20:1) {#if $options.blocks.searchInput === true}",
		ctx
	});

	return block;
}

// (24:2) {#if $options.scrollY}
function create_if_block_1$1(ctx) {
	let stickyheader;
	let current;
	stickyheader = new StickyHeader({ $$inline: true });

	const block = {
		c: function create() {
			create_component(stickyheader.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(stickyheader.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(stickyheader, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(stickyheader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(stickyheader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(stickyheader, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(24:2) {#if $options.scrollY}",
		ctx
	});

	return block;
}

// (31:1) {#if $options.blocks.paginationRowCount === true || $options.blocks.paginationButtons === true}
function create_if_block$2(ctx) {
	let pagination;
	let current;
	pagination = new Pagination({ $$inline: true });

	const block = {
		c: function create() {
			create_component(pagination.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(pagination.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(pagination, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(pagination.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(pagination.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(pagination, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(31:1) {#if $options.blocks.paginationRowCount === true || $options.blocks.paginationButtons === true}",
		ctx
	});

	return block;
}

function create_fragment$4(ctx) {
	let section;
	let t0;
	let article;
	let t1;
	let table;
	let t2;
	let section_class_value;
	let current;
	let if_block0 = /*$options*/ ctx[1].blocks.searchInput === true && create_if_block_2$1(ctx);
	let if_block1 = /*$options*/ ctx[1].scrollY && create_if_block_1$1(ctx);
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let if_block2 = (/*$options*/ ctx[1].blocks.paginationRowCount === true || /*$options*/ ctx[1].blocks.paginationButtons === true) && create_if_block$2(ctx);

	const block = {
		c: function create() {
			section = element("section");
			if (if_block0) if_block0.c();
			t0 = space();
			article = element("article");
			if (if_block1) if_block1.c();
			t1 = space();
			table = element("table");
			if (default_slot) default_slot.c();
			t2 = space();
			if (if_block2) if_block2.c();
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			if (if_block0) if_block0.l(section_nodes);
			t0 = claim_space(section_nodes);
			article = claim_element(section_nodes, "ARTICLE", { class: true });
			var article_nodes = children(article);
			if (if_block1) if_block1.l(article_nodes);
			t1 = claim_space(article_nodes);
			table = claim_element(article_nodes, "TABLE", { class: true });
			var table_nodes = children(table);
			if (default_slot) default_slot.l(table_nodes);
			table_nodes.forEach(detach_dev);
			article_nodes.forEach(detach_dev);
			t2 = claim_space(section_nodes);
			if (if_block2) if_block2.l(section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(table, "class", "svelte-udk322");
			add_location(table, file$4, 26, 2, 801);
			attr_dev(article, "class", "dt-table svelte-udk322");
			add_location(article, file$4, 22, 1, 716);
			attr_dev(section, "class", section_class_value = "datatable " + /*classList*/ ctx[0] + " svelte-udk322");
			toggle_class(section, "scroll-y", /*$options*/ ctx[1].scrollY);
			toggle_class(section, "css", /*$options*/ ctx[1].css);
			add_location(section, file$4, 18, 0, 548);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			if (if_block0) if_block0.m(section, null);
			append_dev(section, t0);
			append_dev(section, article);
			if (if_block1) if_block1.m(article, null);
			append_dev(article, t1);
			append_dev(article, table);

			if (default_slot) {
				default_slot.m(table, null);
			}

			append_dev(section, t2);
			if (if_block2) if_block2.m(section, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*$options*/ ctx[1].blocks.searchInput === true) {
				if (if_block0) {
					if (dirty & /*$options*/ 2) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2$1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(section, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*$options*/ ctx[1].scrollY) {
				if (if_block1) {
					if (dirty & /*$options*/ 2) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(article, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}

			if (/*$options*/ ctx[1].blocks.paginationRowCount === true || /*$options*/ ctx[1].blocks.paginationButtons === true) {
				if (if_block2) {
					if (dirty & /*$options*/ 2) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block$2(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(section, null);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (!current || dirty & /*classList*/ 1 && section_class_value !== (section_class_value = "datatable " + /*classList*/ ctx[0] + " svelte-udk322")) {
				attr_dev(section, "class", section_class_value);
			}

			if (dirty & /*classList, $options*/ 3) {
				toggle_class(section, "scroll-y", /*$options*/ ctx[1].scrollY);
			}

			if (dirty & /*classList, $options*/ 3) {
				toggle_class(section, "css", /*$options*/ ctx[1].css);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(default_slot, local);
			transition_in(if_block2);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(default_slot, local);
			transition_out(if_block2);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
			if (if_block2) if_block2.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let $options;
	validate_store(options, "options");
	component_subscribe($$self, options, $$value => $$invalidate(1, $options = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Datatable", slots, ['default']);
	let { data = [] } = $$props;
	let { settings = {} } = $$props;
	let { classList = "" } = $$props;
	onMount(() => datatable.init());
	onDestroy(() => datatable.reset());
	const writable_props = ["data", "settings", "classList"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Datatable> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("data" in $$props) $$invalidate(2, data = $$props.data);
		if ("settings" in $$props) $$invalidate(3, settings = $$props.settings);
		if ("classList" in $$props) $$invalidate(0, classList = $$props.classList);
		if ("$$scope" in $$props) $$invalidate(4, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		options,
		datatable,
		Search,
		Pagination,
		StickyHeader,
		onMount,
		onDestroy,
		data,
		settings,
		classList,
		$options
	});

	$$self.$inject_state = $$props => {
		if ("data" in $$props) $$invalidate(2, data = $$props.data);
		if ("settings" in $$props) $$invalidate(3, settings = $$props.settings);
		if ("classList" in $$props) $$invalidate(0, classList = $$props.classList);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*data, settings*/ 12) {
			{
				datatable.setRows(data);
				options.update(settings);
			}
		}
	};

	return [classList, $options, data, settings, $$scope, slots];
}

class Datatable extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { data: 2, settings: 3, classList: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Datatable",
			options,
			id: create_fragment$4.name
		});
	}

	get data() {
		throw new Error("<Datatable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set data(value) {
		throw new Error("<Datatable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get settings() {
		throw new Error("<Datatable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set settings(value) {
		throw new Error("<Datatable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get classList() {
		throw new Error("<Datatable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set classList(value) {
		throw new Error("<Datatable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\tables\item.svelte generated by Svelte v3.36.0 */
const file$3 = "src\\components\\tables\\item.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[10] = list[i];
	return child_ctx;
}

// (60:4) {#each $rows as row}
function create_each_block(ctx) {
	let tr;
	let td0;
	let t0_value = /*row*/ ctx[10].name + "";
	let t0;
	let t1;
	let td1;
	let t2_value = /*row*/ ctx[10].description + "";
	let t2;
	let t3;
	let td2;
	let t4_value = /*row*/ ctx[10].price + "";
	let t4;
	let t5;
	let td3;
	let t6_value = /*row*/ ctx[10].stock + "";
	let t6;
	let t7;
	let td4;
	let t8_value = /*formatDate*/ ctx[6](/*row*/ ctx[10].created_at) + "";
	let t8;
	let t9;
	let td5;
	let t10_value = /*formatDate*/ ctx[6](/*row*/ ctx[10].updated_at) + "";
	let t10;
	let t11;
	let td6;
	let div;
	let a0;
	let editicon;
	let t12;
	let a1;
	let trash2icon;
	let t13;
	let current;
	let mounted;
	let dispose;

	editicon = new EditIcon({
			props: { class: "align-middle text-success" },
			$$inline: true
		});

	function click_handler() {
		return /*click_handler*/ ctx[7](/*row*/ ctx[10]);
	}

	trash2icon = new Trash2Icon({
			props: { class: "align-middle text-danger" },
			$$inline: true
		});

	function click_handler_1() {
		return /*click_handler_1*/ ctx[8](/*row*/ ctx[10]);
	}

	const block = {
		c: function create() {
			tr = element("tr");
			td0 = element("td");
			t0 = text(t0_value);
			t1 = space();
			td1 = element("td");
			t2 = text(t2_value);
			t3 = space();
			td2 = element("td");
			t4 = text(t4_value);
			t5 = space();
			td3 = element("td");
			t6 = text(t6_value);
			t7 = space();
			td4 = element("td");
			t8 = text(t8_value);
			t9 = space();
			td5 = element("td");
			t10 = text(t10_value);
			t11 = space();
			td6 = element("td");
			div = element("div");
			a0 = element("a");
			create_component(editicon.$$.fragment);
			t12 = space();
			a1 = element("a");
			create_component(trash2icon.$$.fragment);
			t13 = space();
			this.h();
		},
		l: function claim(nodes) {
			tr = claim_element(nodes, "TR", {});
			var tr_nodes = children(tr);
			td0 = claim_element(tr_nodes, "TD", {});
			var td0_nodes = children(td0);
			t0 = claim_text(td0_nodes, t0_value);
			td0_nodes.forEach(detach_dev);
			t1 = claim_space(tr_nodes);
			td1 = claim_element(tr_nodes, "TD", {});
			var td1_nodes = children(td1);
			t2 = claim_text(td1_nodes, t2_value);
			td1_nodes.forEach(detach_dev);
			t3 = claim_space(tr_nodes);
			td2 = claim_element(tr_nodes, "TD", {});
			var td2_nodes = children(td2);
			t4 = claim_text(td2_nodes, t4_value);
			td2_nodes.forEach(detach_dev);
			t5 = claim_space(tr_nodes);
			td3 = claim_element(tr_nodes, "TD", {});
			var td3_nodes = children(td3);
			t6 = claim_text(td3_nodes, t6_value);
			td3_nodes.forEach(detach_dev);
			t7 = claim_space(tr_nodes);
			td4 = claim_element(tr_nodes, "TD", {});
			var td4_nodes = children(td4);
			t8 = claim_text(td4_nodes, t8_value);
			td4_nodes.forEach(detach_dev);
			t9 = claim_space(tr_nodes);
			td5 = claim_element(tr_nodes, "TD", {});
			var td5_nodes = children(td5);
			t10 = claim_text(td5_nodes, t10_value);
			td5_nodes.forEach(detach_dev);
			t11 = claim_space(tr_nodes);
			td6 = claim_element(tr_nodes, "TD", {});
			var td6_nodes = children(td6);
			div = claim_element(td6_nodes, "DIV", { class: true });
			var div_nodes = children(div);
			a0 = claim_element(div_nodes, "A", { class: true });
			var a0_nodes = children(a0);
			claim_component(editicon.$$.fragment, a0_nodes);
			a0_nodes.forEach(detach_dev);
			t12 = claim_space(div_nodes);

			a1 = claim_element(div_nodes, "A", {
				"data-bs-toggle": true,
				"data-bs-target": true
			});

			var a1_nodes = children(a1);
			claim_component(trash2icon.$$.fragment, a1_nodes);
			a1_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			td6_nodes.forEach(detach_dev);
			t13 = claim_space(tr_nodes);
			tr_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(td0, file$3, 61, 6, 1422);
			add_location(td1, file$3, 62, 6, 1449);
			add_location(td2, file$3, 63, 6, 1483);
			add_location(td3, file$3, 64, 6, 1511);
			add_location(td4, file$3, 65, 6, 1539);
			add_location(td5, file$3, 66, 6, 1584);
			attr_dev(a0, "class", "me-3");
			add_location(a0, file$3, 69, 12, 1702);
			attr_dev(a1, "data-bs-toggle", "modal");
			attr_dev(a1, "data-bs-target", "#deleteModal");
			add_location(a1, file$3, 70, 12, 1822);
			attr_dev(div, "class", "d-flex justify-content-center");
			add_location(div, file$3, 68, 10, 1645);
			add_location(td6, file$3, 67, 6, 1629);
			add_location(tr, file$3, 60, 4, 1410);
		},
		m: function mount(target, anchor) {
			insert_dev(target, tr, anchor);
			append_dev(tr, td0);
			append_dev(td0, t0);
			append_dev(tr, t1);
			append_dev(tr, td1);
			append_dev(td1, t2);
			append_dev(tr, t3);
			append_dev(tr, td2);
			append_dev(td2, t4);
			append_dev(tr, t5);
			append_dev(tr, td3);
			append_dev(td3, t6);
			append_dev(tr, t7);
			append_dev(tr, td4);
			append_dev(td4, t8);
			append_dev(tr, t9);
			append_dev(tr, td5);
			append_dev(td5, t10);
			append_dev(tr, t11);
			append_dev(tr, td6);
			append_dev(td6, div);
			append_dev(div, a0);
			mount_component(editicon, a0, null);
			append_dev(div, t12);
			append_dev(div, a1);
			mount_component(trash2icon, a1, null);
			append_dev(tr, t13);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(a0, "click", click_handler, false, false, false),
					listen_dev(a1, "click", click_handler_1, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if ((!current || dirty & /*$rows*/ 4) && t0_value !== (t0_value = /*row*/ ctx[10].name + "")) set_data_dev(t0, t0_value);
			if ((!current || dirty & /*$rows*/ 4) && t2_value !== (t2_value = /*row*/ ctx[10].description + "")) set_data_dev(t2, t2_value);
			if ((!current || dirty & /*$rows*/ 4) && t4_value !== (t4_value = /*row*/ ctx[10].price + "")) set_data_dev(t4, t4_value);
			if ((!current || dirty & /*$rows*/ 4) && t6_value !== (t6_value = /*row*/ ctx[10].stock + "")) set_data_dev(t6, t6_value);
			if ((!current || dirty & /*$rows*/ 4) && t8_value !== (t8_value = /*formatDate*/ ctx[6](/*row*/ ctx[10].created_at) + "")) set_data_dev(t8, t8_value);
			if ((!current || dirty & /*$rows*/ 4) && t10_value !== (t10_value = /*formatDate*/ ctx[6](/*row*/ ctx[10].updated_at) + "")) set_data_dev(t10, t10_value);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(editicon.$$.fragment, local);
			transition_in(trash2icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(editicon.$$.fragment, local);
			transition_out(trash2icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tr);
			destroy_component(editicon);
			destroy_component(trash2icon);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(60:4) {#each $rows as row}",
		ctx
	});

	return block;
}

// (49:0) <Datatable {settings} data={items}>
function create_default_slot(ctx) {
	let thead;
	let th0;
	let t0;
	let t1;
	let th1;
	let t2;
	let t3;
	let th2;
	let t4;
	let t5;
	let th3;
	let t6;
	let t7;
	let th4;
	let t8;
	let t9;
	let th5;
	let t10;
	let t11;
	let th6;
	let t12;
	let t13;
	let tbody;
	let current;
	let each_value = /*$rows*/ ctx[2];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			thead = element("thead");
			th0 = element("th");
			t0 = text("Name");
			t1 = space();
			th1 = element("th");
			t2 = text("Description");
			t3 = space();
			th2 = element("th");
			t4 = text("Price");
			t5 = space();
			th3 = element("th");
			t6 = text("Stock");
			t7 = space();
			th4 = element("th");
			t8 = text("Created at");
			t9 = space();
			th5 = element("th");
			t10 = text("Updated at");
			t11 = space();
			th6 = element("th");
			t12 = text("Action");
			t13 = space();
			tbody = element("tbody");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			thead = claim_element(nodes, "THEAD", {});
			var thead_nodes = children(thead);
			th0 = claim_element(thead_nodes, "TH", { "data-key": true });
			var th0_nodes = children(th0);
			t0 = claim_text(th0_nodes, "Name");
			th0_nodes.forEach(detach_dev);
			t1 = claim_space(thead_nodes);
			th1 = claim_element(thead_nodes, "TH", { "data-key": true });
			var th1_nodes = children(th1);
			t2 = claim_text(th1_nodes, "Description");
			th1_nodes.forEach(detach_dev);
			t3 = claim_space(thead_nodes);
			th2 = claim_element(thead_nodes, "TH", { "data-key": true });
			var th2_nodes = children(th2);
			t4 = claim_text(th2_nodes, "Price");
			th2_nodes.forEach(detach_dev);
			t5 = claim_space(thead_nodes);
			th3 = claim_element(thead_nodes, "TH", { "data-key": true });
			var th3_nodes = children(th3);
			t6 = claim_text(th3_nodes, "Stock");
			th3_nodes.forEach(detach_dev);
			t7 = claim_space(thead_nodes);
			th4 = claim_element(thead_nodes, "TH", { "data-key": true });
			var th4_nodes = children(th4);
			t8 = claim_text(th4_nodes, "Created at");
			th4_nodes.forEach(detach_dev);
			t9 = claim_space(thead_nodes);
			th5 = claim_element(thead_nodes, "TH", { "data-key": true });
			var th5_nodes = children(th5);
			t10 = claim_text(th5_nodes, "Updated at");
			th5_nodes.forEach(detach_dev);
			t11 = claim_space(thead_nodes);
			th6 = claim_element(thead_nodes, "TH", {});
			var th6_nodes = children(th6);
			t12 = claim_text(th6_nodes, "Action");
			th6_nodes.forEach(detach_dev);
			thead_nodes.forEach(detach_dev);
			t13 = claim_space(nodes);
			tbody = claim_element(nodes, "TBODY", {});
			var tbody_nodes = children(tbody);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(tbody_nodes);
			}

			tbody_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(th0, "data-key", "name");
			add_location(th0, file$3, 50, 4, 1088);
			attr_dev(th1, "data-key", "description");
			add_location(th1, file$3, 51, 4, 1123);
			attr_dev(th2, "data-key", "price");
			add_location(th2, file$3, 52, 4, 1172);
			attr_dev(th3, "data-key", "stock");
			add_location(th3, file$3, 53, 4, 1209);
			attr_dev(th4, "data-key", "created_at");
			add_location(th4, file$3, 54, 4, 1246);
			attr_dev(th5, "data-key", "updated_at");
			add_location(th5, file$3, 55, 4, 1293);
			add_location(th6, file$3, 56, 4, 1340);
			add_location(thead, file$3, 49, 2, 1075);
			add_location(tbody, file$3, 58, 2, 1371);
		},
		m: function mount(target, anchor) {
			insert_dev(target, thead, anchor);
			append_dev(thead, th0);
			append_dev(th0, t0);
			append_dev(thead, t1);
			append_dev(thead, th1);
			append_dev(th1, t2);
			append_dev(thead, t3);
			append_dev(thead, th2);
			append_dev(th2, t4);
			append_dev(thead, t5);
			append_dev(thead, th3);
			append_dev(th3, t6);
			append_dev(thead, t7);
			append_dev(thead, th4);
			append_dev(th4, t8);
			append_dev(thead, t9);
			append_dev(thead, th5);
			append_dev(th5, t10);
			append_dev(thead, t11);
			append_dev(thead, th6);
			append_dev(th6, t12);
			insert_dev(target, t13, anchor);
			insert_dev(target, tbody, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tbody, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*id, $rows, handleUpdate, formatDate*/ 86) {
				each_value = /*$rows*/ ctx[2];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(tbody, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(thead);
			if (detaching) detach_dev(t13);
			if (detaching) detach_dev(tbody);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(49:0) <Datatable {settings} data={items}>",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let datatable;
	let t0;
	let div5;
	let div4;
	let div3;
	let div0;
	let h5;
	let t1;
	let t2;
	let button0;
	let t3;
	let div1;
	let t4;
	let t5;
	let div2;
	let button1;
	let t6;
	let t7;
	let button2;
	let t8;
	let current;
	let mounted;
	let dispose;

	datatable = new Datatable({
			props: {
				settings: /*settings*/ ctx[3],
				data: /*items*/ ctx[0],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(datatable.$$.fragment);
			t0 = space();
			div5 = element("div");
			div4 = element("div");
			div3 = element("div");
			div0 = element("div");
			h5 = element("h5");
			t1 = text("Modal title");
			t2 = space();
			button0 = element("button");
			t3 = space();
			div1 = element("div");
			t4 = text("are u sure delete this item?");
			t5 = space();
			div2 = element("div");
			button1 = element("button");
			t6 = text("no");
			t7 = space();
			button2 = element("button");
			t8 = text("yes");
			this.h();
		},
		l: function claim(nodes) {
			claim_component(datatable.$$.fragment, nodes);
			t0 = claim_space(nodes);

			div5 = claim_element(nodes, "DIV", {
				class: true,
				id: true,
				tabindex: true,
				"aria-labelledby": true,
				"aria-hidden": true
			});

			var div5_nodes = children(div5);
			div4 = claim_element(div5_nodes, "DIV", { class: true });
			var div4_nodes = children(div4);
			div3 = claim_element(div4_nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			div0 = claim_element(div3_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			h5 = claim_element(div0_nodes, "H5", { class: true, id: true });
			var h5_nodes = children(h5);
			t1 = claim_text(h5_nodes, "Modal title");
			h5_nodes.forEach(detach_dev);
			t2 = claim_space(div0_nodes);

			button0 = claim_element(div0_nodes, "BUTTON", {
				type: true,
				class: true,
				"data-bs-dismiss": true,
				"aria-label": true
			});

			children(button0).forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			t3 = claim_space(div3_nodes);
			div1 = claim_element(div3_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			t4 = claim_text(div1_nodes, "are u sure delete this item?");
			div1_nodes.forEach(detach_dev);
			t5 = claim_space(div3_nodes);
			div2 = claim_element(div3_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);

			button1 = claim_element(div2_nodes, "BUTTON", {
				type: true,
				class: true,
				"data-bs-dismiss": true
			});

			var button1_nodes = children(button1);
			t6 = claim_text(button1_nodes, "no");
			button1_nodes.forEach(detach_dev);
			t7 = claim_space(div2_nodes);

			button2 = claim_element(div2_nodes, "BUTTON", {
				type: true,
				class: true,
				"data-bs-dismiss": true
			});

			var button2_nodes = children(button2);
			t8 = claim_text(button2_nodes, "yes");
			button2_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			div3_nodes.forEach(detach_dev);
			div4_nodes.forEach(detach_dev);
			div5_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h5, "class", "modal-title");
			attr_dev(h5, "id", "exampleModalLabel");
			add_location(h5, file$3, 82, 8, 2295);
			attr_dev(button0, "type", "button");
			attr_dev(button0, "class", "btn-close");
			attr_dev(button0, "data-bs-dismiss", "modal");
			attr_dev(button0, "aria-label", "Close");
			add_location(button0, file$3, 83, 8, 2368);
			attr_dev(div0, "class", "modal-header");
			add_location(div0, file$3, 81, 6, 2259);
			attr_dev(div1, "class", "modal-body");
			add_location(div1, file$3, 85, 6, 2482);
			attr_dev(button1, "type", "button");
			attr_dev(button1, "class", "btn btn-secondary");
			attr_dev(button1, "data-bs-dismiss", "modal");
			add_location(button1, file$3, 89, 8, 2602);
			attr_dev(button2, "type", "button");
			attr_dev(button2, "class", "btn btn-danger");
			attr_dev(button2, "data-bs-dismiss", "modal");
			add_location(button2, file$3, 90, 8, 2695);
			attr_dev(div2, "class", "modal-footer");
			add_location(div2, file$3, 88, 6, 2566);
			attr_dev(div3, "class", "modal-content");
			add_location(div3, file$3, 80, 4, 2224);
			attr_dev(div4, "class", "modal-dialog modal-dialog-centered modal-sm");
			add_location(div4, file$3, 79, 2, 2161);
			attr_dev(div5, "class", "modal fade");
			attr_dev(div5, "id", "deleteModal");
			attr_dev(div5, "tabindex", "-1");
			attr_dev(div5, "aria-labelledby", "exampleModalLabel");
			attr_dev(div5, "aria-hidden", "true");
			add_location(div5, file$3, 78, 0, 2047);
		},
		m: function mount(target, anchor) {
			mount_component(datatable, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div5, anchor);
			append_dev(div5, div4);
			append_dev(div4, div3);
			append_dev(div3, div0);
			append_dev(div0, h5);
			append_dev(h5, t1);
			append_dev(div0, t2);
			append_dev(div0, button0);
			append_dev(div3, t3);
			append_dev(div3, div1);
			append_dev(div1, t4);
			append_dev(div3, t5);
			append_dev(div3, div2);
			append_dev(div2, button1);
			append_dev(button1, t6);
			append_dev(div2, t7);
			append_dev(div2, button2);
			append_dev(button2, t8);
			current = true;

			if (!mounted) {
				dispose = listen_dev(button2, "click", /*handleRemove*/ ctx[5], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			const datatable_changes = {};
			if (dirty & /*items*/ 1) datatable_changes.data = /*items*/ ctx[0];

			if (dirty & /*$$scope, $rows, id*/ 8198) {
				datatable_changes.$$scope = { dirty, ctx };
			}

			datatable.$set(datatable_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(datatable.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(datatable.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(datatable, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div5);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let $rows;
	validate_store(rows, "rows");
	component_subscribe($$self, rows, $$value => $$invalidate(2, $rows = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Item", slots, []);
	let dispatch = createEventDispatcher();
	let id;
	let { items = [] } = $$props;

	const settings = {
		sortable: true,
		pagination: true,
		rowPerPage: 10,
		columnFilter: false
	};

	const handleUpdate = async id => {
		let item = items.find(item => item.id == id);
		let data = { item, "status": "update" };
		dispatch("update", data);
	};

	const handleRemove = async () => {
		dispatch("remove", id);

		await fetch(`http://127.0.0.1:8000/api/items/${id}`, {
			method: "delete",
			headers: { "Content-Type": "application/json" }
		});
	};

	const formatDate = v => {
		let date = new Date(v).toLocaleString("id-ID", { dateStyle: "medium" });
		let result = date;
		return result;
	};

	const writable_props = ["items"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Item> was created with unknown prop '${key}'`);
	});

	const click_handler = row => {
		handleUpdate(row.id);
	};

	const click_handler_1 = row => {
		$$invalidate(1, id = row.id);
	};

	$$self.$$set = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	$$self.$capture_state = () => ({
		Datatable,
		rows,
		EditIcon,
		Trash2Icon,
		createEventDispatcher,
		dispatch,
		id,
		items,
		settings,
		handleUpdate,
		handleRemove,
		formatDate,
		$rows
	});

	$$self.$inject_state = $$props => {
		if ("dispatch" in $$props) dispatch = $$props.dispatch;
		if ("id" in $$props) $$invalidate(1, id = $$props.id);
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		items,
		id,
		$rows,
		settings,
		handleUpdate,
		handleRemove,
		formatDate,
		click_handler,
		click_handler_1
	];
}

class Item$2 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { items: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Item",
			options,
			id: create_fragment$3.name
		});
	}

	get items() {
		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\partials\Field.svelte generated by Svelte v3.36.0 */

const file$2 = "src\\components\\partials\\Field.svelte";

// (19:2) {:else}
function create_else_block$1(ctx) {
	let input;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			input = claim_element(nodes, "INPUT", {
				type: true,
				class: true,
				id: true,
				value: true,
				autocomplete: true,
				required: true
			});

			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "type", /*type*/ ctx[3]);
			attr_dev(input, "class", "form-control");
			attr_dev(input, "id", /*name*/ ctx[1]);
			input.value = /*value*/ ctx[0];
			attr_dev(input, "autocomplete", "off");
			input.required = true;
			add_location(input, file$2, 19, 4, 512);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);

			if (!mounted) {
				dispose = listen_dev(input, "input", /*handleInput*/ ctx[7], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*type*/ 8) {
				attr_dev(input, "type", /*type*/ ctx[3]);
			}

			if (dirty & /*name*/ 2) {
				attr_dev(input, "id", /*name*/ ctx[1]);
			}

			if (dirty & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				prop_dev(input, "value", /*value*/ ctx[0]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$1.name,
		type: "else",
		source: "(19:2) {:else}",
		ctx
	});

	return block;
}

// (17:2) {#if type === "textarea"}
function create_if_block_2(ctx) {
	let textarea;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			textarea = element("textarea");
			this.h();
		},
		l: function claim(nodes) {
			textarea = claim_element(nodes, "TEXTAREA", {
				class: true,
				id: true,
				rows: true,
				value: true,
				autocomplete: true,
				required: true
			});

			children(textarea).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(textarea, "class", "form-control");
			attr_dev(textarea, "id", /*name*/ ctx[1]);
			attr_dev(textarea, "rows", /*rows*/ ctx[4]);
			textarea.value = /*value*/ ctx[0];
			attr_dev(textarea, "autocomplete", "off");
			textarea.required = true;
			add_location(textarea, file$2, 17, 4, 377);
		},
		m: function mount(target, anchor) {
			insert_dev(target, textarea, anchor);

			if (!mounted) {
				dispose = listen_dev(textarea, "input", /*handleInput*/ ctx[7], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*name*/ 2) {
				attr_dev(textarea, "id", /*name*/ ctx[1]);
			}

			if (dirty & /*rows*/ 16) {
				attr_dev(textarea, "rows", /*rows*/ ctx[4]);
			}

			if (dirty & /*value*/ 1) {
				prop_dev(textarea, "value", /*value*/ ctx[0]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(textarea);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(17:2) {#if type === \\\"textarea\\\"}",
		ctx
	});

	return block;
}

// (22:2) {#if valid !== 'undefined'}
function create_if_block_1(ctx) {
	let div;
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(/*valid*/ ctx[5]);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t = claim_text(div_nodes, /*valid*/ ctx[5]);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "valid-feedback");
			add_location(div, file$2, 22, 4, 662);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*valid*/ 32) set_data_dev(t, /*valid*/ ctx[5]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(22:2) {#if valid !== 'undefined'}",
		ctx
	});

	return block;
}

// (27:2) {#if invalid !== 'undefined'}
function create_if_block$1(ctx) {
	let div;
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(/*invalid*/ ctx[6]);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t = claim_text(div_nodes, /*invalid*/ ctx[6]);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "invalid-feedback");
			add_location(div, file$2, 27, 4, 765);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*invalid*/ 64) set_data_dev(t, /*invalid*/ ctx[6]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(27:2) {#if invalid !== 'undefined'}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let div;
	let label_1;
	let t0;
	let t1;
	let t2;
	let t3;

	function select_block_type(ctx, dirty) {
		if (/*type*/ ctx[3] === "textarea") return create_if_block_2;
		return create_else_block$1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block0 = current_block_type(ctx);
	let if_block1 = /*valid*/ ctx[5] !== "undefined" && create_if_block_1(ctx);
	let if_block2 = /*invalid*/ ctx[6] !== "undefined" && create_if_block$1(ctx);

	const block = {
		c: function create() {
			div = element("div");
			label_1 = element("label");
			t0 = text(/*label*/ ctx[2]);
			t1 = space();
			if_block0.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (if_block2) if_block2.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			label_1 = claim_element(div_nodes, "LABEL", { for: true, class: true });
			var label_1_nodes = children(label_1);
			t0 = claim_text(label_1_nodes, /*label*/ ctx[2]);
			label_1_nodes.forEach(detach_dev);
			t1 = claim_space(div_nodes);
			if_block0.l(div_nodes);
			t2 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			t3 = claim_space(div_nodes);
			if (if_block2) if_block2.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(label_1, "for", /*name*/ ctx[1]);
			attr_dev(label_1, "class", "form-label");
			add_location(label_1, file$2, 15, 2, 290);
			attr_dev(div, "class", "mb-3");
			add_location(div, file$2, 14, 0, 268);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, label_1);
			append_dev(label_1, t0);
			append_dev(div, t1);
			if_block0.m(div, null);
			append_dev(div, t2);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t3);
			if (if_block2) if_block2.m(div, null);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*label*/ 4) set_data_dev(t0, /*label*/ ctx[2]);

			if (dirty & /*name*/ 2) {
				attr_dev(label_1, "for", /*name*/ ctx[1]);
			}

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(div, t2);
				}
			}

			if (/*valid*/ ctx[5] !== "undefined") {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_1(ctx);
					if_block1.c();
					if_block1.m(div, t3);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*invalid*/ ctx[6] !== "undefined") {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block$1(ctx);
					if_block2.c();
					if_block2.m(div, null);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Field", slots, []);
	let { name } = $$props;
	let { label } = $$props;
	let { type } = $$props;
	let { value } = $$props;
	let { rows = 3 } = $$props;
	let { valid = "undefined" } = $$props;
	let { invalid = "undefined" } = $$props;

	const handleInput = e => {
		$$invalidate(0, value = e.target.value);
	};

	const writable_props = ["name", "label", "type", "value", "rows", "valid", "invalid"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Field> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("name" in $$props) $$invalidate(1, name = $$props.name);
		if ("label" in $$props) $$invalidate(2, label = $$props.label);
		if ("type" in $$props) $$invalidate(3, type = $$props.type);
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
		if ("rows" in $$props) $$invalidate(4, rows = $$props.rows);
		if ("valid" in $$props) $$invalidate(5, valid = $$props.valid);
		if ("invalid" in $$props) $$invalidate(6, invalid = $$props.invalid);
	};

	$$self.$capture_state = () => ({
		name,
		label,
		type,
		value,
		rows,
		valid,
		invalid,
		handleInput
	});

	$$self.$inject_state = $$props => {
		if ("name" in $$props) $$invalidate(1, name = $$props.name);
		if ("label" in $$props) $$invalidate(2, label = $$props.label);
		if ("type" in $$props) $$invalidate(3, type = $$props.type);
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
		if ("rows" in $$props) $$invalidate(4, rows = $$props.rows);
		if ("valid" in $$props) $$invalidate(5, valid = $$props.valid);
		if ("invalid" in $$props) $$invalidate(6, invalid = $$props.invalid);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [value, name, label, type, rows, valid, invalid, handleInput];
}

class Field extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2, create_fragment$2, safe_not_equal, {
			name: 1,
			label: 2,
			type: 3,
			value: 0,
			rows: 4,
			valid: 5,
			invalid: 6
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Field",
			options,
			id: create_fragment$2.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*name*/ ctx[1] === undefined && !("name" in props)) {
			console.warn("<Field> was created without expected prop 'name'");
		}

		if (/*label*/ ctx[2] === undefined && !("label" in props)) {
			console.warn("<Field> was created without expected prop 'label'");
		}

		if (/*type*/ ctx[3] === undefined && !("type" in props)) {
			console.warn("<Field> was created without expected prop 'type'");
		}

		if (/*value*/ ctx[0] === undefined && !("value" in props)) {
			console.warn("<Field> was created without expected prop 'value'");
		}
	}

	get name() {
		throw new Error("<Field>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<Field>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<Field>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<Field>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<Field>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Field>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Field>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Field>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get rows() {
		throw new Error("<Field>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set rows(value) {
		throw new Error("<Field>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get valid() {
		throw new Error("<Field>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set valid(value) {
		throw new Error("<Field>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get invalid() {
		throw new Error("<Field>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set invalid(value) {
		throw new Error("<Field>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\forms\item.svelte generated by Svelte v3.36.0 */
const file$1 = "src\\components\\forms\\item.svelte";

// (98:6) {:else}
function create_else_block(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Update Item");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Update Item");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(98:6) {:else}",
		ctx
	});

	return block;
}

// (96:6) {#if status === 'store'}
function create_if_block(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Add Item");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Add Item");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(96:6) {#if status === 'store'}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let form;
	let field0;
	let updating_value;
	let t0;
	let field1;
	let updating_value_1;
	let t1;
	let field2;
	let updating_value_2;
	let t2;
	let field3;
	let updating_value_3;
	let t3;
	let div;
	let button;
	let t4;
	let a;
	let t5;
	let current;
	let mounted;
	let dispose;

	function field0_value_binding(value) {
		/*field0_value_binding*/ ctx[4](value);
	}

	let field0_props = {
		name: "name",
		label: "Name",
		type: "text"
	};

	if (/*data*/ ctx[0].name !== void 0) {
		field0_props.value = /*data*/ ctx[0].name;
	}

	field0 = new Field({ props: field0_props, $$inline: true });
	binding_callbacks.push(() => bind(field0, "value", field0_value_binding));

	function field1_value_binding(value) {
		/*field1_value_binding*/ ctx[5](value);
	}

	let field1_props = {
		name: "desc",
		label: "Description",
		type: "textarea",
		rows: "3"
	};

	if (/*data*/ ctx[0].description !== void 0) {
		field1_props.value = /*data*/ ctx[0].description;
	}

	field1 = new Field({ props: field1_props, $$inline: true });
	binding_callbacks.push(() => bind(field1, "value", field1_value_binding));

	function field2_value_binding(value) {
		/*field2_value_binding*/ ctx[6](value);
	}

	let field2_props = {
		name: "price",
		label: "Price",
		type: "number"
	};

	if (/*data*/ ctx[0].price !== void 0) {
		field2_props.value = /*data*/ ctx[0].price;
	}

	field2 = new Field({ props: field2_props, $$inline: true });
	binding_callbacks.push(() => bind(field2, "value", field2_value_binding));

	function field3_value_binding(value) {
		/*field3_value_binding*/ ctx[7](value);
	}

	let field3_props = {
		name: "stock",
		label: "Stock",
		type: "number"
	};

	if (/*data*/ ctx[0].stock !== void 0) {
		field3_props.value = /*data*/ ctx[0].stock;
	}

	field3 = new Field({ props: field3_props, $$inline: true });
	binding_callbacks.push(() => bind(field3, "value", field3_value_binding));

	function select_block_type(ctx, dirty) {
		if (/*status*/ ctx[1] === "store") return create_if_block;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			form = element("form");
			create_component(field0.$$.fragment);
			t0 = space();
			create_component(field1.$$.fragment);
			t1 = space();
			create_component(field2.$$.fragment);
			t2 = space();
			create_component(field3.$$.fragment);
			t3 = space();
			div = element("div");
			button = element("button");
			if_block.c();
			t4 = space();
			a = element("a");
			t5 = text("Reset");
			this.h();
		},
		l: function claim(nodes) {
			form = claim_element(nodes, "FORM", { class: true, novalidate: true });
			var form_nodes = children(form);
			claim_component(field0.$$.fragment, form_nodes);
			t0 = claim_space(form_nodes);
			claim_component(field1.$$.fragment, form_nodes);
			t1 = claim_space(form_nodes);
			claim_component(field2.$$.fragment, form_nodes);
			t2 = claim_space(form_nodes);
			claim_component(field3.$$.fragment, form_nodes);
			t3 = claim_space(form_nodes);
			div = claim_element(form_nodes, "DIV", { class: true });
			var div_nodes = children(div);
			button = claim_element(div_nodes, "BUTTON", { type: true, class: true });
			var button_nodes = children(button);
			if_block.l(button_nodes);
			button_nodes.forEach(detach_dev);
			t4 = claim_space(div_nodes);
			a = claim_element(div_nodes, "A", { class: true });
			var a_nodes = children(a);
			t5 = claim_text(a_nodes, "Reset");
			a_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			form_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button, "type", "submit");
			attr_dev(button, "class", "btn btn-primary");
			add_location(button, file$1, 92, 4, 2175);
			attr_dev(a, "class", "btn btn-danger");
			add_location(a, file$1, 101, 4, 2355);
			attr_dev(div, "class", "mt-4 d-flex justify-content-between");
			add_location(div, file$1, 91, 2, 2120);
			attr_dev(form, "class", "needs-validation");
			form.noValidate = true;
			add_location(form, file$1, 69, 0, 1628);
		},
		m: function mount(target, anchor) {
			insert_dev(target, form, anchor);
			mount_component(field0, form, null);
			append_dev(form, t0);
			mount_component(field1, form, null);
			append_dev(form, t1);
			mount_component(field2, form, null);
			append_dev(form, t2);
			mount_component(field3, form, null);
			append_dev(form, t3);
			append_dev(form, div);
			append_dev(div, button);
			if_block.m(button, null);
			append_dev(div, t4);
			append_dev(div, a);
			append_dev(a, t5);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(a, "click", /*resetForm*/ ctx[3], false, false, false),
					listen_dev(
						form,
						"submit",
						prevent_default(function () {
							if (is_function(/*submit*/ ctx[2])) /*submit*/ ctx[2].apply(this, arguments);
						}),
						false,
						true,
						false
					)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, [dirty]) {
			ctx = new_ctx;
			const field0_changes = {};

			if (!updating_value && dirty & /*data*/ 1) {
				updating_value = true;
				field0_changes.value = /*data*/ ctx[0].name;
				add_flush_callback(() => updating_value = false);
			}

			field0.$set(field0_changes);
			const field1_changes = {};

			if (!updating_value_1 && dirty & /*data*/ 1) {
				updating_value_1 = true;
				field1_changes.value = /*data*/ ctx[0].description;
				add_flush_callback(() => updating_value_1 = false);
			}

			field1.$set(field1_changes);
			const field2_changes = {};

			if (!updating_value_2 && dirty & /*data*/ 1) {
				updating_value_2 = true;
				field2_changes.value = /*data*/ ctx[0].price;
				add_flush_callback(() => updating_value_2 = false);
			}

			field2.$set(field2_changes);
			const field3_changes = {};

			if (!updating_value_3 && dirty & /*data*/ 1) {
				updating_value_3 = true;
				field3_changes.value = /*data*/ ctx[0].stock;
				add_flush_callback(() => updating_value_3 = false);
			}

			field3.$set(field3_changes);

			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(button, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(field0.$$.fragment, local);
			transition_in(field1.$$.fragment, local);
			transition_in(field2.$$.fragment, local);
			transition_in(field3.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(field0.$$.fragment, local);
			transition_out(field1.$$.fragment, local);
			transition_out(field2.$$.fragment, local);
			transition_out(field3.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(form);
			destroy_component(field0);
			destroy_component(field1);
			destroy_component(field2);
			destroy_component(field3);
			if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Item", slots, []);
	let dispatch = createEventDispatcher();
	let { status = "store" } = $$props;

	let { data = {
		"name": "",
		"description": "",
		"price": "",
		"stock": ""
	} } = $$props;

	let submit;

	const storeItem = async () => {
		let method = status === "store" ? "post" : "put";

		let url = status === "store"
		? "http://127.0.0.1:8000/api/items"
		: `http://127.0.0.1:8000/api/items/${data.id}`;

		const res = await fetch(url, {
			method,
			headers: { "Content-Type": "application/json" },
			body: JSON.stringify(data)
		});

		const json = await res.json();
		$$invalidate(0, data = json.data);

		if (status === "store") {
			dispatch("add", data);
		} else {
			dispatch("updated", data);
		}

		resetForm();
	};

	const resetForm = () => {
		$$invalidate(0, data = {
			"name": "",
			"description": "",
			"price": "",
			"stock": ""
		});

		dispatch("reset");
	};

	onMount(async () => {
		$$invalidate(2, submit = () => {
			var forms = document.querySelectorAll(".needs-validation");

			Array.prototype.slice.call(forms).forEach(function (form) {
				if (!form.checkValidity()) {
					event.preventDefault();
					event.stopPropagation();
					form.classList.add("was-validated");
				} else {
					storeItem();
					form.classList.remove("was-validated");
				}
			});
		});
	});

	const writable_props = ["status", "data"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Item> was created with unknown prop '${key}'`);
	});

	function field0_value_binding(value) {
		if ($$self.$$.not_equal(data.name, value)) {
			data.name = value;
			$$invalidate(0, data);
		}
	}

	function field1_value_binding(value) {
		if ($$self.$$.not_equal(data.description, value)) {
			data.description = value;
			$$invalidate(0, data);
		}
	}

	function field2_value_binding(value) {
		if ($$self.$$.not_equal(data.price, value)) {
			data.price = value;
			$$invalidate(0, data);
		}
	}

	function field3_value_binding(value) {
		if ($$self.$$.not_equal(data.stock, value)) {
			data.stock = value;
			$$invalidate(0, data);
		}
	}

	$$self.$$set = $$props => {
		if ("status" in $$props) $$invalidate(1, status = $$props.status);
		if ("data" in $$props) $$invalidate(0, data = $$props.data);
	};

	$$self.$capture_state = () => ({
		Field,
		onMount,
		createEventDispatcher,
		dispatch,
		status,
		data,
		submit,
		storeItem,
		resetForm
	});

	$$self.$inject_state = $$props => {
		if ("dispatch" in $$props) dispatch = $$props.dispatch;
		if ("status" in $$props) $$invalidate(1, status = $$props.status);
		if ("data" in $$props) $$invalidate(0, data = $$props.data);
		if ("submit" in $$props) $$invalidate(2, submit = $$props.submit);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		data,
		status,
		submit,
		resetForm,
		field0_value_binding,
		field1_value_binding,
		field2_value_binding,
		field3_value_binding
	];
}

class Item$1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { status: 1, data: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Item",
			options,
			id: create_fragment$1.name
		});
	}

	get status() {
		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set status(value) {
		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get data() {
		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set data(value) {
		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\routes\admin\item.svelte generated by Svelte v3.36.0 */
const file = "src\\routes\\admin\\item.svelte";

function create_fragment(ctx) {
	let t0;
	let div7;
	let div6;
	let div2;
	let div1;
	let div0;
	let itemtable;
	let t1;
	let div5;
	let div4;
	let div3;
	let itemform;
	let current;

	itemtable = new Item$2({
			props: { items: /*items*/ ctx[0] },
			$$inline: true
		});

	itemtable.$on("remove", /*handleRemove*/ ctx[4]);
	itemtable.$on("update", /*handleUpdate*/ ctx[5]);

	itemform = new Item$1({
			props: {
				status: /*status*/ ctx[2],
				data: /*data*/ ctx[1]
			},
			$$inline: true
		});

	itemform.$on("add", /*handleAdd*/ ctx[3]);
	itemform.$on("updated", /*handleUpdated*/ ctx[6]);
	itemform.$on("reset", /*handleReset*/ ctx[7]);

	const block = {
		c: function create() {
			t0 = space();
			div7 = element("div");
			div6 = element("div");
			div2 = element("div");
			div1 = element("div");
			div0 = element("div");
			create_component(itemtable.$$.fragment);
			t1 = space();
			div5 = element("div");
			div4 = element("div");
			div3 = element("div");
			create_component(itemform.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-r5rsx8\"]", document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			div7 = claim_element(nodes, "DIV", { class: true });
			var div7_nodes = children(div7);
			div6 = claim_element(div7_nodes, "DIV", { class: true });
			var div6_nodes = children(div6);
			div2 = claim_element(div6_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			claim_component(itemtable.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			t1 = claim_space(div6_nodes);
			div5 = claim_element(div6_nodes, "DIV", { class: true });
			var div5_nodes = children(div5);
			div4 = claim_element(div5_nodes, "DIV", { class: true });
			var div4_nodes = children(div4);
			div3 = claim_element(div4_nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			claim_component(itemform.$$.fragment, div3_nodes);
			div3_nodes.forEach(detach_dev);
			div4_nodes.forEach(detach_dev);
			div5_nodes.forEach(detach_dev);
			div6_nodes.forEach(detach_dev);
			div7_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			document.title = "Item";
			attr_dev(div0, "class", "card-body");
			add_location(div0, file, 65, 8, 1434);
			attr_dev(div1, "class", "card shadow mb-4 svelte-1jtad21");
			add_location(div1, file, 64, 6, 1394);
			attr_dev(div2, "class", "col-md-8 col-sm-12");
			add_location(div2, file, 63, 4, 1354);
			attr_dev(div3, "class", "card-body");
			add_location(div3, file, 72, 8, 1667);
			attr_dev(div4, "class", "card shadow mb-4 svelte-1jtad21");
			add_location(div4, file, 71, 6, 1627);
			attr_dev(div5, "class", "col-md-4 col-sm-12");
			add_location(div5, file, 70, 4, 1587);
			attr_dev(div6, "class", "row");
			add_location(div6, file, 62, 2, 1331);
			attr_dev(div7, "class", "container");
			add_location(div7, file, 61, 0, 1304);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, div7, anchor);
			append_dev(div7, div6);
			append_dev(div6, div2);
			append_dev(div2, div1);
			append_dev(div1, div0);
			mount_component(itemtable, div0, null);
			append_dev(div6, t1);
			append_dev(div6, div5);
			append_dev(div5, div4);
			append_dev(div4, div3);
			mount_component(itemform, div3, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const itemtable_changes = {};
			if (dirty & /*items*/ 1) itemtable_changes.items = /*items*/ ctx[0];
			itemtable.$set(itemtable_changes);
			const itemform_changes = {};
			if (dirty & /*status*/ 4) itemform_changes.status = /*status*/ ctx[2];
			if (dirty & /*data*/ 2) itemform_changes.data = /*data*/ ctx[1];
			itemform.$set(itemform_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(itemtable.$$.fragment, local);
			transition_in(itemform.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(itemtable.$$.fragment, local);
			transition_out(itemform.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div7);
			destroy_component(itemtable);
			destroy_component(itemform);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function preload() {
	const res = await this.fetch("http://127.0.0.1:8000/api/items");
	const data = await res.json();

	if (res.status === 200) {
		return { message: data.message, items: data.data };
	} else {
		this.error(res.status, data.message);
	}
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Item", slots, []);
	let { items = [] } = $$props;
	let data;
	let status;

	const handleAdd = e => {
		let item = e.detail;
		$$invalidate(0, items = [...items, item]);
	};

	const handleRemove = e => {
		$$invalidate(0, items = items.filter(item => item.id != e.detail));
	};

	const handleUpdate = e => {
		$$invalidate(1, data = e.detail.item);
		$$invalidate(2, status = e.detail.status);
	};

	const handleUpdated = e => {
		let currentItem = items.filter(item => item.id == e.detail.id);

		$$invalidate(0, items = items.map(item => {
			if (JSON.stringify(item) === JSON.stringify(currentItem[0])) {
				return e.detail;
			} else {
				return item;
			}
		}));

		$$invalidate(2, status = "store");
	};

	const handleReset = () => {
		$$invalidate(2, status = "store");
	};

	const writable_props = ["items"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Item> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	$$self.$capture_state = () => ({
		preload,
		ItemTable: Item$2,
		ItemForm: Item$1,
		items,
		data,
		status,
		handleAdd,
		handleRemove,
		handleUpdate,
		handleUpdated,
		handleReset
	});

	$$self.$inject_state = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
		if ("data" in $$props) $$invalidate(1, data = $$props.data);
		if ("status" in $$props) $$invalidate(2, status = $$props.status);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		items,
		data,
		status,
		handleAdd,
		handleRemove,
		handleUpdate,
		handleUpdated,
		handleReset
	];
}

class Item extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { items: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Item",
			options,
			id: create_fragment.name
		});
	}

	get items() {
		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default Item;
export { preload };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaXRlbS4zMjljZGVjZS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1mZWF0aGVyLWljb25zL3NyYy9pY29ucy9FZGl0SWNvbi5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLWZlYXRoZXItaWNvbnMvc3JjL2ljb25zL1RyYXNoMkljb24uc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1zaW1wbGUtZGF0YXRhYmxlcy9zcmMvc3RvcmVzL29wdGlvbnMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLXNpbXBsZS1kYXRhdGFibGVzL3NyYy9zdG9yZXMvc3RhdGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLXNpbXBsZS1kYXRhdGFibGVzL3NyYy9zdG9yZXMvZmlsdGVycy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtc2ltcGxlLWRhdGF0YWJsZXMvc3JjL3N0b3Jlcy9kYXRhLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1zaW1wbGUtZGF0YXRhYmxlcy9zcmMvc3RvcmVzL2NvbHVtbnMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLXNpbXBsZS1kYXRhdGFibGVzL3NyYy9kYXRhdGFibGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLXNpbXBsZS1kYXRhdGFibGVzL3NyYy9TZWFyY2hJbnB1dC5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLXNpbXBsZS1kYXRhdGFibGVzL3NyYy9jb21wb25lbnRzL1NlYXJjaC5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLXNpbXBsZS1kYXRhdGFibGVzL3NyYy9QYWdpbmF0aW9uUm93Q291bnQuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1zaW1wbGUtZGF0YXRhYmxlcy9zcmMvUGFnaW5hdGlvbkJ1dHRvbnMuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1zaW1wbGUtZGF0YXRhYmxlcy9zcmMvY29tcG9uZW50cy9QYWdpbmF0aW9uLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtc2ltcGxlLWRhdGF0YWJsZXMvc3JjL2NvbXBvbmVudHMvaGVhZGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1zaW1wbGUtZGF0YXRhYmxlcy9zcmMvY29tcG9uZW50cy9TdGlja3lIZWFkZXIuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1zaW1wbGUtZGF0YXRhYmxlcy9zcmMvRGF0YXRhYmxlLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3RhYmxlcy9pdGVtLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3BhcnRpYWxzL0ZpZWxkLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL2Zvcm1zL2l0ZW0uc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9hZG1pbi9pdGVtLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICBleHBvcnQgbGV0IHNpemUgPSBcIjEwMCVcIjtcbiAgZXhwb3J0IGxldCBzdHJva2VXaWR0aCA9IDI7XG4gIGxldCBjdXN0b21DbGFzcyA9IFwiXCI7XG4gIGV4cG9ydCB7IGN1c3RvbUNsYXNzIGFzIGNsYXNzIH07XG5cbiAgaWYgKHNpemUgIT09IFwiMTAwJVwiKSB7XG4gICAgc2l6ZSA9IHNpemUuc2xpY2UoLTEpID09PSAneCcgXG4gICAgICAgICAgPyBzaXplLnNsaWNlKDAsIHNpemUubGVuZ3RoIC0xKSArICdlbSdcbiAgICAgICAgICA6IHBhcnNlSW50KHNpemUpICsgJ3B4JztcbiAgfVxuPC9zY3JpcHQ+XG5cbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPXtzaXplfSBoZWlnaHQ9e3NpemV9IGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCJ7c3Ryb2tlV2lkdGh9XCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgY2xhc3M9XCJmZWF0aGVyIGZlYXRoZXItZWRpdCB7Y3VzdG9tQ2xhc3N9XCI+PHBhdGggZD1cIk0xMSA0SDRhMiAyIDAgMCAwLTIgMnYxNGEyIDIgMCAwIDAgMiAyaDE0YTIgMiAwIDAgMCAyLTJ2LTdcIj48L3BhdGg+PHBhdGggZD1cIk0xOC41IDIuNWEyLjEyMSAyLjEyMSAwIDAgMSAzIDNMMTIgMTVsLTQgMSAxLTQgOS41LTkuNXpcIj48L3BhdGg+PC9zdmc+XG4iLCI8c2NyaXB0PlxuICBleHBvcnQgbGV0IHNpemUgPSBcIjEwMCVcIjtcbiAgZXhwb3J0IGxldCBzdHJva2VXaWR0aCA9IDI7XG4gIGxldCBjdXN0b21DbGFzcyA9IFwiXCI7XG4gIGV4cG9ydCB7IGN1c3RvbUNsYXNzIGFzIGNsYXNzIH07XG5cbiAgaWYgKHNpemUgIT09IFwiMTAwJVwiKSB7XG4gICAgc2l6ZSA9IHNpemUuc2xpY2UoLTEpID09PSAneCcgXG4gICAgICAgICAgPyBzaXplLnNsaWNlKDAsIHNpemUubGVuZ3RoIC0xKSArICdlbSdcbiAgICAgICAgICA6IHBhcnNlSW50KHNpemUpICsgJ3B4JztcbiAgfVxuPC9zY3JpcHQ+XG5cbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPXtzaXplfSBoZWlnaHQ9e3NpemV9IGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCJ7c3Ryb2tlV2lkdGh9XCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgY2xhc3M9XCJmZWF0aGVyIGZlYXRoZXItdHJhc2gtMiB7Y3VzdG9tQ2xhc3N9XCI+PHBvbHlsaW5lIHBvaW50cz1cIjMgNiA1IDYgMjEgNlwiPjwvcG9seWxpbmU+PHBhdGggZD1cIk0xOSA2djE0YTIgMiAwIDAgMS0yIDJIN2EyIDIgMCAwIDEtMi0yVjZtMyAwVjRhMiAyIDAgMCAxIDItMmg0YTIgMiAwIDAgMSAyIDJ2MlwiPjwvcGF0aD48bGluZSB4MT1cIjEwXCIgeTE9XCIxMVwiIHgyPVwiMTBcIiB5Mj1cIjE3XCI+PC9saW5lPjxsaW5lIHgxPVwiMTRcIiB5MT1cIjExXCIgeDI9XCIxNFwiIHkyPVwiMTdcIj48L2xpbmU+PC9zdmc+XG4iLCJpbXBvcnQgeyB3cml0YWJsZSB9IGZyb20gJ3N2ZWx0ZS9zdG9yZSdcclxuXHJcbmNvbnN0IGNyZWF0ZU9wdGlvbnMgPSAoKSA9PiB7XHJcbiAgICBjb25zdCB7c3Vic2NyaWJlLCBzZXQgfSA9IHdyaXRhYmxlKHtcclxuICAgICAgICBzb3J0YWJsZTogdHJ1ZSxcclxuICAgICAgICBwYWdpbmF0aW9uOiB0cnVlLFxyXG4gICAgICAgIHJvd1BlclBhZ2U6IDUwLFxyXG4gICAgICAgIGNvbHVtbkZpbHRlcjogZmFsc2UsXHJcbiAgICAgICAgc2Nyb2xsWTogdHJ1ZSxcclxuICAgICAgICBjc3M6IHRydWUsXHJcbiAgICAgICAgbGFiZWxzOiB7XHJcbiAgICAgICAgICAgIHNlYXJjaDogJ1NlYXJjaC4uLicsXHJcbiAgICAgICAgICAgIGZpbHRlcjogJ0ZpbHRlcicsXHJcbiAgICAgICAgICAgIG5vUm93czogJ05vIGVudHJpZXMgdG8gZm91bmQnLFxyXG4gICAgICAgICAgICBpbmZvOiAnU2hvd2luZyB7c3RhcnR9IHRvIHtlbmR9IG9mIHtyb3dzfSBlbnRyaWVzJyxcclxuICAgICAgICAgICAgcHJldmlvdXM6ICdQcmV2aW91cycsXHJcbiAgICAgICAgICAgIG5leHQ6ICdOZXh0JyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJsb2Nrczoge1xyXG4gICAgICAgICAgICBzZWFyY2hJbnB1dDogdHJ1ZSwgXHJcbiAgICAgICAgICAgIHBhZ2luYXRpb25CdXR0b25zOiB0cnVlLFxyXG4gICAgICAgICAgICBwYWdpbmF0aW9uUm93Q291bnQ6IHRydWUsXHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc3Vic2NyaWJlLCBzZXQsIFxyXG4gICAgICAgIGdldDogKCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgJHN0b3JlXHJcbiAgICAgICAgICAgIG9wdGlvbnMuc3Vic2NyaWJlKHN0b3JlID0+ICRzdG9yZSA9IHN0b3JlKVxyXG4gICAgICAgICAgICByZXR1cm4gJHN0b3JlXHJcbiAgICAgICAgfSxcclxuICAgICAgICB1cGRhdGU6IChvcHQpID0+IHtcclxuICAgICAgICAgICAgb3B0LmxhYmVscyA9IG9wdC5sYWJlbHMgPyBvcHQubGFiZWxzIDoge31cclxuICAgICAgICAgICAgY29uc3QgbGFiZWxzID0ge1xyXG4gICAgICAgICAgICAgICAgc2VhcmNoOiAgIHR5cGVvZiBvcHQubGFiZWxzLnNlYXJjaCAgID09PSAnc3RyaW5nJyA/IG9wdC5sYWJlbHMuc2VhcmNoICAgOiAnU2VhcmNoLi4uJyxcclxuICAgICAgICAgICAgICAgIGZpbHRlcjogICB0eXBlb2Ygb3B0LmxhYmVscy5maWx0ZXIgICA9PT0gJ3N0cmluZycgPyBvcHQubGFiZWxzLmZpbHRlciAgIDogJ0ZpbHRlcicsXHJcbiAgICAgICAgICAgICAgICBub1Jvd3M6ICAgdHlwZW9mIG9wdC5sYWJlbHMubm9Sb3dzICAgPT09ICdzdHJpbmcnID8gb3B0LmxhYmVscy5ub1Jvd3MgICA6ICdObyBlbnRyaWVzIHRvIGZvdW5kJyxcclxuICAgICAgICAgICAgICAgIGluZm86ICAgICB0eXBlb2Ygb3B0LmxhYmVscy5pbmZvICAgICA9PT0gJ3N0cmluZycgPyBvcHQubGFiZWxzLmluZm8gICAgIDogJ1Nob3dpbmcge3N0YXJ0fSB0byB7ZW5kfSBvZiB7cm93c30gZW50cmllcycsXHJcbiAgICAgICAgICAgICAgICBwcmV2aW91czogdHlwZW9mIG9wdC5sYWJlbHMucHJldmlvdXMgPT09ICdzdHJpbmcnID8gb3B0LmxhYmVscy5wcmV2aW91cyA6ICdQcmV2aW91cycsXHJcbiAgICAgICAgICAgICAgICBuZXh0OiAgICAgdHlwZW9mIG9wdC5sYWJlbHMubmV4dCAgICAgPT09ICdzdHJpbmcnID8gb3B0LmxhYmVscy5uZXh0ICAgICA6ICdOZXh0JywgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH0gICBcclxuICAgICAgICAgICAgb3B0LmJsb2NrcyA9IG9wdC5ibG9ja3MgPyBvcHQuYmxvY2tzIDoge31cclxuICAgICAgICAgICAgY29uc3QgYmxvY2tzID0ge1xyXG4gICAgICAgICAgICAgICAgc2VhcmNoSW5wdXQ6ICAgICAgICB0eXBlb2Ygb3B0LmJsb2Nrcy5zZWFyY2hJbnB1dCAgICAgICAgPT09ICdib29sZWFuJyA/IG9wdC5ibG9ja3Muc2VhcmNoSW5wdXQgICAgICAgIDogdHJ1ZSwgXHJcbiAgICAgICAgICAgICAgICBwYWdpbmF0aW9uQnV0dG9uczogIHR5cGVvZiBvcHQuYmxvY2tzLnBhZ2luYXRpb25CdXR0b25zICA9PT0gJ2Jvb2xlYW4nID8gb3B0LmJsb2Nrcy5wYWdpbmF0aW9uQnV0dG9ucyAgOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgcGFnaW5hdGlvblJvd0NvdW50OiB0eXBlb2Ygb3B0LmJsb2Nrcy5wYWdpbmF0aW9uUm93Q291bnQgPT09ICdib29sZWFuJyA/IG9wdC5ibG9ja3MucGFnaW5hdGlvblJvd0NvdW50IDogdHJ1ZSxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSB7XHJcbiAgICAgICAgICAgICAgICBzb3J0YWJsZTogICAgIHR5cGVvZiBvcHQuc29ydGFibGUgICAgID09PSAnYm9vbGVhbicgPyBvcHQuc29ydGFibGUgICAgIDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHBhZ2luYXRpb246ICAgdHlwZW9mIG9wdC5wYWdpbmF0aW9uICAgPT09ICdib29sZWFuJyA/IG9wdC5wYWdpbmF0aW9uICAgOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgcm93UGVyUGFnZTogICB0eXBlb2Ygb3B0LnJvd1BlclBhZ2UgICA9PT0gJ251bWJlcicgID8gb3B0LnJvd1BlclBhZ2UgICA6IDUwLFxyXG4gICAgICAgICAgICAgICAgY29sdW1uRmlsdGVyOiB0eXBlb2Ygb3B0LmNvbHVtbkZpbHRlciA9PT0gJ2Jvb2xlYW4nID8gb3B0LmNvbHVtbkZpbHRlciA6IGZhbHNlLCBcclxuICAgICAgICAgICAgICAgIHNjcm9sbFk6ICAgICAgdHlwZW9mIG9wdC5zY3JvbGxZICAgICAgPT09ICdib29sZWFuJyA/IG9wdC5zY3JvbGxZICAgICAgOiB0cnVlLCBcclxuICAgICAgICAgICAgICAgIGNzczogICAgICAgICAgdHlwZW9mIG9wdC5jc3MgICAgICAgICAgPT09ICdib29sZWFuJyA/IG9wdC5jc3MgICAgICAgICAgOiB0cnVlLCBcclxuICAgICAgICAgICAgICAgIGxhYmVsczogbGFiZWxzLFxyXG4gICAgICAgICAgICAgICAgYmxvY2tzOiBibG9ja3NcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcHRpb25zLnNldChwYXJzZWQpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjb25zdCBvcHRpb25zID0gY3JlYXRlT3B0aW9ucygpIiwiaW1wb3J0IHsgd3JpdGFibGUgfSBmcm9tICdzdmVsdGUvc3RvcmUnXHJcbmltcG9ydCB7IG9wdGlvbnMgfSBmcm9tICcuL29wdGlvbnMuanMnXHJcblxyXG5leHBvcnQgY29uc3Qgcm93Q291bnQgPSB3cml0YWJsZSgwKVxyXG5cclxuY29uc3QgY3JlYXRlUGFnZU51bWJlciA9ICgpID0+IHtcclxuXHRjb25zdCB7IHN1YnNjcmliZSwgdXBkYXRlIH0gPSB3cml0YWJsZSgxKVxyXG5cdHJldHVybiB7XHJcblx0XHRzdWJzY3JpYmUsIHVwZGF0ZSxcclxuXHRcdHNldDogKG51bWJlcikgPT4gdXBkYXRlKHN0b3JlID0+IHtcclxuXHRcdFx0bGV0ICRyb3dQZXJQYWdlLCAkcm93Q291bnRcclxuXHRcdFx0cm93Q291bnQuc3Vic2NyaWJlKHN0b3JlID0+ICRyb3dDb3VudCA9IHN0b3JlKVxyXG5cdFx0XHRvcHRpb25zLnN1YnNjcmliZShzdG9yZSA9PiAkcm93UGVyUGFnZSA9IHN0b3JlLnJvd1BlclBhZ2UpXHJcblx0XHRcdGlmICggbnVtYmVyID49IDEgJiYgbnVtYmVyIDw9IE1hdGguY2VpbCgkcm93Q291bnQgLyAkcm93UGVyUGFnZSkgKSB7XHJcblx0XHRcdFx0c3RvcmUgPSBwYXJzZUludChudW1iZXIpXHJcblx0XHRcdH1cclxuXHRcdFx0ZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc2VjdGlvbi5kYXRhdGFibGUgLmR0LXRhYmxlJykuc2Nyb2xsVG9wID0gMFxyXG5cdFx0XHRyZXR1cm4gc3RvcmVcclxuXHRcdH0pXHJcblx0fVxyXG59XHJcbmV4cG9ydCBjb25zdCBwYWdlTnVtYmVyID0gY3JlYXRlUGFnZU51bWJlcigpXHJcblxyXG5leHBvcnQgY29uc3QgZGF0YXRhYmxlV2lkdGggPSB3cml0YWJsZShudWxsKSIsImltcG9ydCB7IHdyaXRhYmxlIH0gZnJvbSAnc3ZlbHRlL3N0b3JlJ1xyXG5cclxuY29uc3QgY3JlYXRlTG9jYWwgPSAoKSA9PiB7XHJcblx0Y29uc3QgeyBzdWJzY3JpYmUsIHVwZGF0ZSB9ID0gd3JpdGFibGUoW10pXHJcblx0cmV0dXJuIHtcclxuXHRcdHN1YnNjcmliZSwgdXBkYXRlLFxyXG5cdFx0YWRkOiAoa2V5LCB2YWx1ZSkgPT4gdXBkYXRlKHN0b3JlID0+IHtcclxuXHRcdFx0Y29uc3QgZmlsdGVyID0ge2tleToga2V5LCB2YWx1ZTogdmFsdWV9IFxyXG5cdFx0XHRzdG9yZSA9IHN0b3JlLmZpbHRlcihpdGVtID0+IHsgcmV0dXJuIGl0ZW0ua2V5ICE9PSBrZXkgJiYgaXRlbS52YWx1ZS5sZW5ndGggPiAwIH0pXHJcblx0XHRcdHN0b3JlLnB1c2goZmlsdGVyKVxyXG5cdFx0XHRyZXR1cm4gc3RvcmVcclxuXHRcdH0pLFxyXG5cdFx0cmVtb3ZlOiAoKSA9PiB1cGRhdGUoc3RvcmUgPT4gc3RvcmUgPSBbXSlcclxuXHR9XHJcbn1cclxuZXhwb3J0IGNvbnN0IGxvY2FsID0gY3JlYXRlTG9jYWwoKVxyXG5cclxuY29uc3QgY3JlYXRlR2xvYmFsID0gKCkgPT4ge1xyXG5cdGNvbnN0IHsgc3Vic2NyaWJlLCB1cGRhdGUgfSA9IHdyaXRhYmxlKG51bGwpXHJcblx0cmV0dXJuIHtcclxuXHRcdHN1YnNjcmliZSwgXHJcblx0XHRzZXQ6ICh2YWx1ZSkgPT4gdXBkYXRlKHN0b3JlID0+IHtcclxuXHRcdFx0c3RvcmUgPSAodmFsdWUubGVuZ3RoID4gMCkgPyB2YWx1ZSA6IG51bGxcclxuXHRcdFx0cmV0dXJuIHN0b3JlXHJcblx0XHR9KSxcclxuXHRcdHJlbW92ZTogKCkgPT4gdXBkYXRlKHN0b3JlID0+IHN0b3JlID0gbnVsbClcclxuXHR9XHJcbn1cclxuZXhwb3J0IGNvbnN0IGdsb2JhbCA9IGNyZWF0ZUdsb2JhbCgpIiwiaW1wb3J0IHsgd3JpdGFibGUsIGRlcml2ZWQgfSBmcm9tICdzdmVsdGUvc3RvcmUnXHJcbmltcG9ydCB7IG9wdGlvbnMgfSBmcm9tICcuL29wdGlvbnMuanMnXHJcbmltcG9ydCB7IHBhZ2VOdW1iZXIsIHJvd0NvdW50IH0gZnJvbSAnLi9zdGF0ZS5qcydcclxuaW1wb3J0IHsgZ2xvYmFsLCBsb2NhbCB9IGZyb20gJy4vZmlsdGVycy5qcydcclxuXHJcblxyXG5jb25zdCBjcmVhdGVEYXRhID0gKCkgPT4ge1xyXG5cdGNvbnN0IHsgc3Vic2NyaWJlLCBzZXQsIHVwZGF0ZSB9ID0gd3JpdGFibGUoW10pXHJcblx0cmV0dXJuIHtcclxuXHRcdHN1YnNjcmliZSwgc2V0LFxyXG5cdFx0c29ydEFzYzogKGtleSkgPT4gdXBkYXRlKHN0b3JlID0+IHtcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRzdG9yZS5zb3J0KCAoYSwgYikgPT4ga2V5KGIpLmxvY2FsZUNvbXBhcmUoa2V5KGEpKSApXHJcblx0XHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0XHRyZXR1cm4gc3RvcmUuc29ydCggKGEsIGIpID0+IHBhcnNlRmxvYXQoa2V5KGIpKSAtIHBhcnNlRmxvYXQoa2V5KGEpKSlcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gc3RvcmUuc29ydCggKGEsIGIpID0+IGtleShiKS5sb2NhbGVDb21wYXJlKGtleShhKSkgKVxyXG5cdFx0XHRcclxuXHRcdH0pLFxyXG5cdFx0c29ydERlc2M6IChrZXkpID0+IHVwZGF0ZShzdG9yZSA9PiB7XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0c3RvcmUuc29ydCggKGEsIGIpID0+IGtleShhKS5sb2NhbGVDb21wYXJlKGtleShiKSkgKVxyXG5cdFx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdFx0cmV0dXJuIHN0b3JlLnNvcnQoIChhLCBiKSA9PiBwYXJzZUZsb2F0KGtleShhKSkgLSBwYXJzZUZsb2F0KGtleShiKSkpXHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHN0b3JlLnNvcnQoIChhLCBiKSA9PiBrZXkoYSkubG9jYWxlQ29tcGFyZShrZXkoYikpIClcclxuXHRcdH0pLFxyXG5cdH1cclxufVxyXG5leHBvcnQgY29uc3QgZGF0YSA9IGNyZWF0ZURhdGEoKVxyXG5cclxuZXhwb3J0IGNvbnN0IGZpbHRlcmVkID0gZGVyaXZlZChcclxuXHRbZGF0YSwgZ2xvYmFsLCBsb2NhbF0sXHJcbiAgICAoWyRkYXRhLCAkZ2xvYmFsLCAkbG9jYWxdKSA9PiB7XHJcblx0XHRpZiAoJGdsb2JhbCkge1xyXG5cdFx0XHQkZGF0YSA9ICRkYXRhLmZpbHRlciggaXRlbSA9PiB7XHJcblx0XHRcdFx0cmV0dXJuIE9iamVjdC5rZXlzKGl0ZW0pLnNvbWUoIGsgPT4ge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGl0ZW1ba10udG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJGdsb2JhbC50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkpID4gLTFcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHR9KVxyXG5cdFx0fVxyXG5cdFx0aWYgKCRsb2NhbC5sZW5ndGggPiAwKSB7XHJcblx0XHRcdCRsb2NhbC5mb3JFYWNoKGZpbHRlciA9PiB7XHJcblx0XHRcdFx0cmV0dXJuICRkYXRhID0gJGRhdGEuZmlsdGVyKCBpdGVtID0+IGZpbHRlci5rZXkoaXRlbSkudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoZmlsdGVyLnZhbHVlLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSkgPiAtMSlcclxuXHRcdFx0fSlcclxuXHRcdH1cclxuXHRcdHJvd0NvdW50LnNldCgkZGF0YS5sZW5ndGgpXHJcblx0XHRyZXR1cm4gJGRhdGFcclxuXHR9IFx0XHJcbilcclxuXHJcbmV4cG9ydCBjb25zdCByb3dzID0gZGVyaXZlZChcclxuXHRbZmlsdGVyZWQsIG9wdGlvbnMsIHBhZ2VOdW1iZXJdLFxyXG4gICAgKFskZmlsdGVyZWQsICRvcHRpb25zLCAkcGFnZU51bWJlcl0pID0+IHtcclxuXHRcdGlmICghJG9wdGlvbnMucGFnaW5hdGlvbikge1xyXG5cdFx0XHRyZXR1cm4gJGZpbHRlcmVkXHJcblx0XHR9XHJcblx0XHRyZXR1cm4gJGZpbHRlcmVkLnNsaWNlKCAoJHBhZ2VOdW1iZXIgLSAxKSAqICRvcHRpb25zLnJvd1BlclBhZ2UsICRwYWdlTnVtYmVyICogJG9wdGlvbnMucm93UGVyUGFnZSkgXHJcblx0fSBcclxuKSIsImltcG9ydCB7IHdyaXRhYmxlIH0gZnJvbSAnc3ZlbHRlL3N0b3JlJ1xyXG5pbXBvcnQgeyBvcHRpb25zIH0gZnJvbSAnLi4vc3RvcmVzL29wdGlvbnMuanMnXHJcbmltcG9ydCB7IGRhdGEgfSBmcm9tICcuLi9zdG9yZXMvZGF0YS5qcydcclxuaW1wb3J0IHsgcGFnZU51bWJlciB9IGZyb20gJy4uL3N0b3Jlcy9zdGF0ZS5qcydcclxuaW1wb3J0IHsgbG9jYWwgfSBmcm9tICcuLi9zdG9yZXMvZmlsdGVycy5qcydcclxuXHJcbmNvbnN0IGNyZWF0ZUNvbHVtbnMgPSAoKSA9PiB7XHJcblx0Y29uc3QgeyBzdWJzY3JpYmUsIHNldCwgdXBkYXRlIH0gPSB3cml0YWJsZShbXSlcclxuXHRyZXR1cm4ge1xyXG5cdFx0c3Vic2NyaWJlLCBzZXQsIHVwZGF0ZSxcclxuXHRcdGdldDogKCkgPT4ge1xyXG5cdFx0XHRsZXQgJGNvbHVtbnNcclxuXHRcdFx0Y29sdW1ucy5zdWJzY3JpYmUoc3RvcmUgPT4gJGNvbHVtbnMgPSBzdG9yZSlcclxuXHRcdFx0cmV0dXJuICRjb2x1bW5zXHJcblx0XHR9LFxyXG5cdFx0c29ydDogKGVsZW1lbnQsIGtleSkgPT4ge1xyXG5cdFx0XHRpZiAob3B0aW9ucy5nZXQoKS5zb3J0YWJsZSAhPT0gdHJ1ZSB8fCB0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJykge1xyXG5cdFx0XHRcdHJldHVyblxyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChcclxuXHRcdFx0XHRlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnc29ydGFibGUnKSAmJlxyXG5cdFx0XHRcdGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdhc2MnKVxyXG5cdFx0XHQpIHtcclxuXHRcdFx0XHRBcnJheS5mcm9tKGVsZW1lbnQucGFyZW50Tm9kZS5jaGlsZHJlbikuZm9yRWFjaCgoaXRlbSkgPT5cclxuXHRcdFx0XHRcdGl0ZW0uY2xhc3NMaXN0LnJlbW92ZSgnYXNjJywgJ2Rlc2MnKVxyXG5cdFx0XHRcdClcclxuXHRcdFx0XHRlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2Rlc2MnKVxyXG5cdFx0XHRcdGRhdGEuc29ydERlc2Moa2V5KVxyXG5cdFx0XHRcdHBhZ2VOdW1iZXIuc2V0KDEpXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0QXJyYXkuZnJvbShlbGVtZW50LnBhcmVudE5vZGUuY2hpbGRyZW4pLmZvckVhY2goKGl0ZW0pID0+XHJcblx0XHRcdFx0XHRpdGVtLmNsYXNzTGlzdC5yZW1vdmUoJ2Rlc2MnLCAnYXNjJylcclxuXHRcdFx0XHQpXHJcblx0XHRcdFx0ZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdhc2MnKVxyXG5cdFx0XHRcdGRhdGEuc29ydEFzYyhrZXkpXHJcblx0XHRcdFx0cGFnZU51bWJlci5zZXQoMSlcclxuXHRcdFx0fVxyXG5cdFx0XHRjb2x1bW5zLnJlZHJhdygpXHJcblx0XHR9LFxyXG5cdFx0ZmlsdGVyOiAoa2V5LCB2YWx1ZSkgPT4ge1xyXG5cdFx0XHRwYWdlTnVtYmVyLnNldCgxKVxyXG5cdFx0XHRsb2NhbC5hZGQoa2V5LCB2YWx1ZSlcclxuXHRcdFx0Y29sdW1ucy5yZWRyYXcoKVxyXG5cdFx0fSxcclxuXHRcdGRyYXc6ICgpID0+IHtcclxuXHRcdFx0c2V0VGltZW91dCgoKSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgdGJvZHkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZGF0YXRhYmxlIHRhYmxlIHRib2R5IHRyJylcclxuXHRcdFx0XHRpZiAodGJvZHkgPT09IG51bGwpIHJldHVyblxyXG5cdFx0XHRcdGNvbnN0IHRoZWFkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmR0LWhlYWRlciB0aGVhZCB0cicpXHJcblx0XHRcdFx0Y29uc3QgJGNvbHVtbnMgPSBjb2x1bW5zLmdldCgpXHJcblx0XHRcdFx0dGhlYWQuZm9yRWFjaCh0ciA9PiB7XHJcblx0XHRcdFx0XHRsZXQgaSA9IDBcclxuXHRcdFx0XHRcdEFycmF5LmZyb20odGJvZHkuY2hpbGRyZW4pLmZvckVhY2godGQgPT4ge1xyXG5cdFx0XHRcdFx0XHRsZXQgdGggPSB0ci5jaGlsZHJlbltpXVxyXG5cdFx0XHRcdFx0XHRsZXQgdGhXID0gdGguZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGhcclxuXHRcdFx0XHRcdFx0bGV0IHRkVyA9IHRkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoXHJcblx0XHRcdFx0XHRcdC8vIGxldCBjb2x1bW5NaW5XaWR0aCA9IHBhcnNlRmxvYXQoY29sdW1ucy5nZXQoKVtpXS5taW5XaWR0aC5yZXBsYWNlKCdweCcsICcnKSlcclxuXHRcdFx0XHRcdFx0aWYgKHRkVyA+IHRoVykgeyBcclxuXHRcdFx0XHRcdFx0XHR0aC5zdHlsZS5taW5XaWR0aCA9IHRkVyArICdweCdcclxuXHRcdFx0XHRcdFx0XHR0aC5zdHlsZS5tYXhXaWR0aCA9IHRkVyArICdweCdcclxuXHRcdFx0XHRcdFx0XHQkY29sdW1uc1tpXS5taW5XaWR0aCA9IHRkV1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdHRkLnN0eWxlLm1pbldpZHRoID0gdGhXICsgJ3B4J1xyXG5cdFx0XHRcdFx0XHRcdHRkLnN0eWxlLm1heFdpZHRoID0gdGhXICsgJ3B4J1xyXG5cdFx0XHRcdFx0XHRcdCRjb2x1bW5zW2ldLm1pbldpZHRoID0gdGhXXHJcblx0XHRcdFx0XHRcdH0gXHJcblx0XHRcdFx0XHRcdGkrK1xyXG5cdFx0XHRcdFx0fSlcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHR9LCA1MClcdFxyXG5cdFx0fSxcclxuXHRcdHJlZHJhdzogKCkgPT4ge1xyXG5cdFx0XHRpZiAoIG9wdGlvbnMuZ2V0KCkuc2Nyb2xsWSA9PT0gZmFsc2UgKSB7XHJcblx0XHRcdFx0cmV0dXJuXHJcblx0XHRcdH1cclxuXHRcdFx0c2V0VGltZW91dCgoKSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgdGJvZHkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZGF0YXRhYmxlIHRhYmxlIHRib2R5IHRyJylcclxuXHRcdFx0XHRpZiAodGJvZHkgPT09IG51bGwpIHJldHVyblxyXG5cdFx0XHRcdGNvbnN0IHRoZWFkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmR0LWhlYWRlciB0aGVhZCB0cicpXHJcblx0XHRcdFx0dGhlYWQuZm9yRWFjaCh0ciA9PiB7XHJcblx0XHRcdFx0XHRsZXQgaSA9IDBcclxuXHRcdFx0XHRcdEFycmF5LmZyb20odGJvZHkuY2hpbGRyZW4pLmZvckVhY2godGQgPT4ge1xyXG5cdFx0XHRcdFx0XHRsZXQgdGggPSB0ci5jaGlsZHJlbltpXVxyXG5cdFx0XHRcdFx0XHRsZXQgdGhXID0gdGguZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGhcclxuXHRcdFx0XHRcdFx0bGV0IHRkVyA9IHRkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoXHJcblx0XHRcdFx0XHRcdGxldCBjb2x1bW5NaW5XaWR0aCA9IHBhcnNlRmxvYXQoY29sdW1ucy5nZXQoKVtpXS5taW5XaWR0aClcclxuXHRcdFx0XHRcdFx0aWYgKHRkVyA+IHRoVyB8fCB0aFcgPiBjb2x1bW5NaW5XaWR0aCkgeyBcclxuXHRcdFx0XHRcdFx0XHR0aC5zdHlsZS5taW5XaWR0aCA9IHRkVyArICdweCdcclxuXHRcdFx0XHRcdFx0XHR0aC5zdHlsZS5tYXhXaWR0aCA9IHRkVyArICdweCdcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHR0ZC5zdHlsZS5taW5XaWR0aCA9IHRoVyArICdweCdcclxuXHRcdFx0XHRcdFx0XHR0ZC5zdHlsZS5tYXhXaWR0aCA9IHRoVyArICdweCdcclxuXHRcdFx0XHRcdFx0fSBcclxuXHRcdFx0XHRcdFx0aSsrXHJcblx0XHRcdFx0XHR9KVxyXG5cdFx0XHRcdH0pXHJcblx0XHRcdH0sIDUwKVx0XHRcdFxyXG5cdFx0fSxcclxuXHR9XHJcbn1cclxuZXhwb3J0IGNvbnN0IGNvbHVtbnMgPSBjcmVhdGVDb2x1bW5zKCkiLCJpbXBvcnQgeyBkYXRhIH0gZnJvbSAnLi9zdG9yZXMvZGF0YS5qcydcclxuaW1wb3J0IHsgb3B0aW9ucyB9IGZyb20gJy4vc3RvcmVzL29wdGlvbnMuanMnXHJcbmltcG9ydCB7IGNvbHVtbnMgfSBmcm9tICcuL3N0b3Jlcy9jb2x1bW5zLmpzJ1xyXG5pbXBvcnQgeyBkYXRhdGFibGVXaWR0aCwgcGFnZU51bWJlciB9IGZyb20gJy4vc3RvcmVzL3N0YXRlLmpzJ1xyXG5pbXBvcnQgeyBnbG9iYWwsIGxvY2FsIH0gZnJvbSAnLi9zdG9yZXMvZmlsdGVycy5qcydcclxuXHJcblxyXG5leHBvcnQgY29uc3QgZGF0YXRhYmxlID0ge1xyXG4gICAgaW5pdDogKCkgPT4ge1xyXG4gICAgICAgIGRhdGF0YWJsZS5yZXNpemUoKVxyXG4gICAgICAgIGRhdGF0YWJsZS5hZGRFdmVudFNjcm9sbFgoKVxyXG4gICAgICAgIGRhdGF0YWJsZS5nZXRDb2x1bW5zKClcclxuICAgICAgICBuZXcgUmVzaXplT2JzZXJ2ZXIoKG11dGF0aW9ucykgPT4ge1xyXG4gICAgICAgICAgICBkYXRhdGFibGUucmVzaXplKClcclxuICAgICAgICB9KS5vYnNlcnZlKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3NlY3Rpb24uZGF0YXRhYmxlJykucGFyZW50RWxlbWVudClcclxuICAgIH0sXHJcbiAgICByZXNldDogKCkgPT4ge1xyXG4gICAgICAgIHBhZ2VOdW1iZXIudXBkYXRlKHN0b3JlID0+IHN0b3JlID0gMSlcclxuICAgICAgICBnbG9iYWwucmVtb3ZlKClcclxuICAgICAgICBsb2NhbC5yZW1vdmUoKVxyXG4gICAgICAgIGNvbHVtbnMuc2V0KFtdKVxyXG4gICAgfSxcclxuICAgIHNldFJvd3M6IChhcnIpID0+IHtcclxuICAgICAgICBhcnIuZm9yRWFjaCggKGl0ZW0pID0+IHtcclxuICAgICAgICAgICAgT2JqZWN0LmtleXMoaXRlbSkuZm9yRWFjaCggKGspID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpdGVtW2tdID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbVtrXSA9ICcnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSlcclxuICAgICAgICBkYXRhLnNldChhcnIpXHJcbiAgICAgICAgcmV0dXJuXHJcbiAgICB9LFxyXG4gICAgZ2V0U2l6ZTogKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3NlY3Rpb24uZGF0YXRhYmxlJykucGFyZW50Tm9kZVxyXG4gICAgICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnQpXHJcbiAgICAgICAgY29uc3QgcmVjdCA9IHBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxyXG4gICAgICAgIGNvbnN0IGdldE51bWJlciA9IChweFZhbHVlKSA9PiB7IHJldHVybiBwYXJzZUZsb2F0KHB4VmFsdWUucmVwbGFjZSgncHgnLCAnJykpICB9IFxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHBhcmVudFdpZHRoOiByZWN0LndpZHRoLFxyXG4gICAgICAgICAgICBwYXJlbnRIZWlnaHQ6IHJlY3QuaGVpZ2h0LFxyXG4gICAgICAgICAgICB3aWR0aDogKHJlY3Qud2lkdGggLSBnZXROdW1iZXIoc3R5bGUucGFkZGluZ0xlZnQpIC0gZ2V0TnVtYmVyKHN0eWxlLnBhZGRpbmdSaWdodCkgLSBnZXROdW1iZXIoc3R5bGUuYm9yZGVyTGVmdFdpZHRoKSAtIGdldE51bWJlcihzdHlsZS5ib3JkZXJSaWdodFdpZHRoKSkgLyByZWN0LndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IChyZWN0LmhlaWdodCAtIGdldE51bWJlcihzdHlsZS5wYWRkaW5nVG9wKSAtIGdldE51bWJlcihzdHlsZS5wYWRkaW5nQm90dG9tKSAtIGdldE51bWJlcihzdHlsZS5ib3JkZXJUb3BXaWR0aCkgLSBnZXROdW1iZXIoc3R5bGUuYm9yZGVyQm90dG9tV2lkdGgpKSAvIHJlY3QuaGVpZ2h0LFxyXG4gICAgICAgICAgICB0b3A6IHN0eWxlLnBhZGRpbmdUb3AsXHJcbiAgICAgICAgICAgIHJpZ2h0OiBzdHlsZS5wYWRkaW5nUmlnaHQsXHJcbiAgICAgICAgICAgIGJvdHRvbTogc3R5bGUucGFkZGluZ0JvdHRvbSxcclxuICAgICAgICAgICAgbGVmdDogc3R5bGUucGFkZGluZ0xlZnRcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgcmVzaXplOiAoKSA9PiB7XHJcbiAgICAgICAgaWYgKCAhZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc2VjdGlvbi5kYXRhdGFibGUnKSApIHJldHVyblxyXG4gICAgICAgIGNvbnN0IHNpemUgPSBkYXRhdGFibGUuZ2V0U2l6ZSgpXHJcbiAgICAgICAgY29uc3QgdGFibGVDb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzZWN0aW9uLmRhdGF0YWJsZSAuZHQtdGFibGUnKVxyXG4gICAgICAgIGlmICggb3B0aW9ucy5nZXQoKS5zY3JvbGxZICkge1xyXG4gICAgICAgICAgICB0YWJsZUNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBkYXRhdGFibGUuZ2V0VGFibGVDb250YWluZXJIZWlnaHQoc2l6ZS5wYXJlbnRIZWlnaHQgKiBzaXplLmhlaWdodCkgKyAncHgnXHJcbiAgICAgICAgICAgIGNvbHVtbnMucmVkcmF3KClcclxuICAgICAgICB9XHJcbiAgICAgICAgZGF0YXRhYmxlV2lkdGguc2V0KCBzaXplLnBhcmVudFdpZHRoICogc2l6ZS53aWR0aCApXHJcbiAgICAgICAgaWYgKHNpemUucGFyZW50V2lkdGggKiBzaXplLndpZHRoIDwgZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc2VjdGlvbi5kYXRhdGFibGUgdGFibGUnKS5vZmZzZXRXaWR0aCkge1xyXG4gICAgICAgICAgICB0YWJsZUNvbnRhaW5lci5zdHlsZS5vdmVyZmxvd1ggPSAnYXV0bydcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgZ2V0VGFibGVDb250YWluZXJIZWlnaHQ6IChoZWlnaHQpID0+IHtcclxuICAgICAgICBsZXQgcGFnaW5hdGlvbkJsb2NrXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuZ2V0KCkucGFnaW5hdGlvbiAmJiAob3B0aW9ucy5nZXQoKS5ibG9ja3MucGFnaW5hdGlvbkJ1dHRvbnMgfHwgb3B0aW9ucy5nZXQoKS5ibG9ja3MucGFnaW5hdGlvblJvd0NvdW50KSkge1xyXG4gICAgICAgICAgICBwYWdpbmF0aW9uQmxvY2sgPSB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNhbGMgPSBbXHJcbiAgICAgICAgICAgIChvcHRpb25zLmdldCgpLmJsb2Nrcy5zZWFyY2hJbnB1dCkgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZGF0YXRhYmxlIC5kdC1zZWFyY2gnKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgOiAwLFxyXG4gICAgICAgICAgICAocGFnaW5hdGlvbkJsb2NrKSA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5kYXRhdGFibGUgLmR0LXBhZ2luYXRpb24nKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgOiAwXHJcbiAgICAgICAgXVxyXG4gICAgICAgIGNvbnN0IHN1bSA9IChhLCBiKSA9PiBhICsgYlxyXG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3NlY3Rpb24uZGF0YXRhYmxlIC5kdC10YWJsZScpLnN0eWxlLmhlaWdodCA9IGhlaWdodCAtIGNhbGMucmVkdWNlKHN1bSkgKyAncHgnXHJcbiAgICB9LFxyXG4gICAgYWRkRXZlbnRTY3JvbGxYOiAoKSA9PiB7XHJcbiAgICAgICAgaWYgKCBvcHRpb25zLmdldCgpLnNjcm9sbFkgKSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3NlY3Rpb24uZGF0YXRhYmxlIC5kdC10YWJsZScpLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZHQtaGVhZGVyJykuc3R5bGUubGVmdCA9ICgtMSAqIGUudGFyZ2V0LnNjcm9sbExlZnQpICsgJ3B4J1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBnZXRDb2x1bW5zOiAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY29sdW1uTGlzdCA9IFtdXHJcbiAgICAgICAgbGV0IGkgPSAwXHJcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmRhdGF0YWJsZSB0YWJsZSB0aGVhZCB0aCcpLmZvckVhY2godGggPT4ge1xyXG4gICAgICAgICAgICBjb2x1bW5MaXN0LnB1c2goe1xyXG4gICAgICAgICAgICAgICAgaW5kZXg6IGksXHJcbiAgICAgICAgICAgICAgICBodG1sOiB0aC5pbm5lckhUTUwsXHJcbiAgICAgICAgICAgICAgICBrZXk6IGRhdGF0YWJsZS5nZXRLZXkodGguZGF0YXNldC5rZXkpLFxyXG4gICAgICAgICAgICAgICAgc29ydDogbnVsbCxcclxuICAgICAgICAgICAgICAgIGNsYXNzTGlzdDogdGguY2xhc3NMaXN0LFxyXG4gICAgICAgICAgICAgICAgbWluV2lkdGg6IHRoLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIHRoLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbHVtbnMuc29ydChlLnRhcmdldCwgZGF0YXRhYmxlLmdldEtleSh0aC5kYXRhc2V0LmtleSkpXHJcbiAgICAgICAgICAgIH0sIHRydWUpXHJcbiAgICAgICAgICAgIGkrK1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgY29sdW1ucy5zZXQoY29sdW1uTGlzdClcclxuICAgIH0sXHJcbiAgICBnZXRLZXk6IChrZXkpID0+IHtcclxuICAgICAgICBpZiAoIWtleSkgIHJldHVybiBcclxuICAgICAgICBpZiAoa2V5ICYmIGtleS5pbmRleE9mKCc9PicpID4gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKGAndXNlIHN0cmljdCc7cmV0dXJuICgke2tleX0pYCkoKVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKHgpID0+IHhba2V5XVxyXG4gICAgfSxcclxufVxyXG5cclxuIiwiPHNjcmlwdD5cclxuICAgIGltcG9ydCB7IG9wdGlvbnMgfSBmcm9tICcuL3N0b3Jlcy9vcHRpb25zLmpzJ1xyXG4gICAgaW1wb3J0IHsgcGFnZU51bWJlciB9IGZyb20gJy4vc3RvcmVzL3N0YXRlLmpzJ1xyXG4gICAgaW1wb3J0IHsgY29sdW1ucyB9IGZyb20gJy4vc3RvcmVzL2NvbHVtbnMuanMnXHJcbiAgICBpbXBvcnQgeyBnbG9iYWwgfSBmcm9tICcuL3N0b3Jlcy9maWx0ZXJzLmpzJ1xyXG4gICAgZXhwb3J0IGxldCByZWYgPSAnJ1xyXG4gICAgZXhwb3J0IGxldCBjbGFzc0xpc3QgPSAnJ1xyXG4gICAgY29uc3Qgc2VhcmNoID0gKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgcGFnZU51bWJlci5zZXQoMSlcclxuICAgICAgICBnbG9iYWwuc2V0KHZhbHVlKVxyXG4gICAgICAgIGNvbHVtbnMucmVkcmF3KClcclxuICAgIH1cclxuPC9zY3JpcHQ+XHJcblxyXG48aW5wdXQgXHJcbiAgICBjbGFzcz1cIntjbGFzc0xpc3R9XCJcclxuICAgIGNsYXNzOmNzcz17JG9wdGlvbnMuY3NzfSBcclxuICAgIHR5cGU9XCJ0ZXh0XCIgXHJcbiAgICBwbGFjZWhvbGRlcj1cInskb3B0aW9ucy5sYWJlbHMuc2VhcmNofVwiIFxyXG4gICAgb246aW5wdXQ9eyhlKSA9PiBzZWFyY2goZS50YXJnZXQudmFsdWUpfSBcclxuICAgIHtyZWZ9XHJcbi8+XHJcblxyXG48c3R5bGU+XHJcbiAgICBpbnB1dC5jc3N7Ym9yZGVyOjFweCBzb2xpZCAjZTBlMGUwO2JvcmRlci1yYWRpdXM6NHB4O291dGxpbmU6bm9uZTtwYWRkaW5nOjAgOHB4O2xpbmUtaGVpZ2h0OjI0cHg7bWFyZ2luOjA7aGVpZ2h0OjI0cHg7YmFja2dyb3VuZDp0cmFuc3BhcmVudDt3aWR0aDoxNzZweDt0cmFuc2l0aW9uOmFsbCwgMC4xczt9XHJcbiAgICBpbnB1dC5jc3M6Zm9jdXN7Ym9yZGVyOjJweCBzb2xpZCAjZTBlMGUwfVxyXG4gICAgaW5wdXQuY3NzOjpwbGFjZWhvbGRlciB7Y29sb3I6IzllOWU5ZTtsaW5lLWhlaWdodDoyNHB4O31cclxuPC9zdHlsZT4iLCI8c2NyaXB0PlxyXG4gICAgaW1wb3J0IFNlYXJjaElucHV0IGZyb20gXCIuLi9TZWFyY2hJbnB1dC5zdmVsdGVcIlxyXG4gICAgaW1wb3J0IHsgb3B0aW9ucyB9IGZyb20gJy4uL3N0b3Jlcy9vcHRpb25zLmpzJ1xyXG48L3NjcmlwdD5cclxuXHJcbjxzZWN0aW9uIGNsYXNzPVwiZHQtc2VhcmNoXCIgY2xhc3M6Y3NzPXskb3B0aW9ucy5jc3N9PlxyXG4gICAgPFNlYXJjaElucHV0IC8+XHJcbjwvc2VjdGlvbj5cclxuXHJcbjxzdHlsZT5cclxuICAgIHNlY3Rpb24ge1xyXG4gICAgICAgIGhlaWdodDogMzJweDtcclxuICAgIH1cclxuICAgIC5jc3N7bWFyZ2luLWxlZnQ6IDE2cHg7fVxyXG48L3N0eWxlPlxyXG4iLCI8c2NyaXB0PlxyXG4gICAgaW1wb3J0IHsgb3B0aW9ucyB9IGZyb20gJy4vc3RvcmVzL29wdGlvbnMuanMnXHJcbiAgICBpbXBvcnQgeyBwYWdlTnVtYmVyLCByb3dDb3VudCwgZGF0YXRhYmxlV2lkdGggfSBmcm9tICcuL3N0b3Jlcy9zdGF0ZS5qcydcclxuICAgICQ6IHN0YXJ0ID0gJHBhZ2VOdW1iZXIgKiAkb3B0aW9ucy5yb3dQZXJQYWdlIC0gJG9wdGlvbnMucm93UGVyUGFnZSArIDFcclxuICAgICQ6IGVuZCA9IE1hdGgubWluKCRwYWdlTnVtYmVyICogJG9wdGlvbnMucm93UGVyUGFnZSwgJHJvd0NvdW50KVxyXG4gICAgJDogcm93cyA9ICRyb3dDb3VudFxyXG4gICAgJDogaW5mbyA9ICRvcHRpb25zLmxhYmVscy5pbmZvLnJlcGxhY2UoJ3tzdGFydH0nLCBgPGI+JHtzdGFydH08L2I+YCkucmVwbGFjZSgne2VuZH0nLCBgPGI+JHtlbmR9PC9iPmApLnJlcGxhY2UoJ3tyb3dzfScsIGA8Yj4ke3Jvd3N9PC9iPmApXHJcbjwvc2NyaXB0PlxyXG5cclxuXHJcblxyXG48YXNpZGUgY2xhc3M9XCJkdC1wYWdpbmF0aW9uLXJvd2NvdW50XCIgY2xhc3M6Y3NzPXskb3B0aW9ucy5jc3N9PlxyXG4gICAgeyNpZiAkZGF0YXRhYmxlV2lkdGggPiA2MDB9XHJcbiAgICAgICAgeyNpZiByb3dzID4gMH1cclxuICAgICAgICAgICAge0BodG1sIGluZm99XHJcbiAgICAgICAgezplbHNlfVxyXG4gICAgICAgICAgICB7QGh0bWwgJG9wdGlvbnMubGFiZWxzLm5vUm93c31cclxuICAgICAgICB7L2lmfVxyXG4gICAgezplbHNlfVxyXG4gICAgICAgIHtAaHRtbCBgPGI+JHtzdGFydH08L2I+LTxiPiR7ZW5kfTwvYj4vPGI+JHtyb3dzfTwvYj5gIH1cclxuICAgIHsvaWZ9XHJcbjwvYXNpZGU+XHJcblxyXG48c3R5bGU+XHJcbiAgICAuY3Nze2NvbG9yOiM2MTYxNjE7bGluZS1oZWlnaHQ6MzJweDttYXJnaW4tbGVmdDoxNnB4O2ZvbnQtc2l6ZToxNHB4O31cclxuPC9zdHlsZT4iLCJcclxuPHNjcmlwdD5cclxuICAgIGltcG9ydCB7IG9wdGlvbnMgfSBmcm9tICcuL3N0b3Jlcy9vcHRpb25zLmpzJ1xyXG4gICAgaW1wb3J0IHsgcm93Q291bnQsIHBhZ2VOdW1iZXIsIGRhdGF0YWJsZVdpZHRoIH0gZnJvbSAnLi9zdG9yZXMvc3RhdGUuanMnXHJcbiAgICBpbXBvcnQgeyBjb2x1bW5zIH0gZnJvbSAnLi9zdG9yZXMvY29sdW1ucy5qcydcclxuICAgIGV4cG9ydCBsZXQgcmVmID0gJydcclxuICAgIGV4cG9ydCBsZXQgY2xhc3NMaXN0ID0gJydcclxuICAgICQ6IHBhZ2VDb3VudCA9IEFycmF5LmZyb20oIEFycmF5KCBNYXRoLmNlaWwoJHJvd0NvdW50IC8gJG9wdGlvbnMucm93UGVyUGFnZSkpLmtleXMoKSApXHJcbiAgICBjb25zdCBzbGljZSA9IChhcnIsIHBhZ2UpID0+IHtcclxuICAgICAgICBpZiAocGFnZSA8IDUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFyci5zbGljZSggMCwgNSApXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhZ2UgPiBhcnIubGVuZ3RoIC0gNCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXJyLnNsaWNlKCBhcnIubGVuZ3RoIC0gNSwgYXJyLmxlbmd0aCApXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcnIuc2xpY2UoIHBhZ2UgLSAyLCBwYWdlICsgMSApXHJcbiAgICB9XHJcbiAgICAkOiBidXR0b25zID0gc2xpY2UocGFnZUNvdW50LCAkcGFnZU51bWJlcilcclxuICAgIGNvbnN0IHNldFBhZ2UgPSAobnVtYmVyKSA9PiB7XHJcbiAgICAgICAgcGFnZU51bWJlci5zZXQobnVtYmVyKVxyXG4gICAgICAgIGNvbHVtbnMucmVkcmF3KClcclxuICAgIH1cclxuPC9zY3JpcHQ+XHJcblxyXG57I2lmICRkYXRhdGFibGVXaWR0aCA+IDYwMH1cclxuICAgIDxzZWN0aW9uIGNsYXNzPVwiZHQtcGFnaW5hdGlvbi1idXR0b25zIHtjbGFzc0xpc3R9XCIge3JlZn0gY2xhc3M6Y3NzPXskb3B0aW9ucy5jc3N9PlxyXG4gICAgICAgIDxidXR0b24gXHJcbiAgICAgICAgICAgIGNsYXNzPVwidGV4dFwiXHJcbiAgICAgICAgICAgIGNsYXNzOmRpc2FibGVkPXskcGFnZU51bWJlciA9PT0gMX1cclxuICAgICAgICAgICAgb246Y2xpY2s9eygpID0+IHNldFBhZ2UoJHBhZ2VOdW1iZXIgLSAxKX1cclxuICAgICAgICA+XHJcbiAgICAgICAgICAgIHtAaHRtbCAkb3B0aW9ucy5sYWJlbHMucHJldmlvdXN9XHJcbiAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgPGJ1dHRvbiBjbGFzczphY3RpdmU9eyRwYWdlTnVtYmVyID09PSAxfSBvbjpjbGljaz17KCkgPT4gc2V0UGFnZSgxKX0+XHJcbiAgICAgICAgICAgIDFcclxuICAgICAgICA8L2J1dHRvbj4gIFxyXG4gICAgICAgIHsjaWYgcGFnZUNvdW50Lmxlbmd0aCA+IDYgJiYgJHBhZ2VOdW1iZXIgPj0gNX1cclxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImVsbGlwc2VcIj4uLi48L2J1dHRvbj5cclxuICAgICAgICB7L2lmfVxyXG5cclxuICAgICAgICB7I2VhY2ggYnV0dG9ucyBhcyBufVxyXG4gICAgICAgICAgICB7I2lmIG4gPiAwICYmIG4gPCBwYWdlQ291bnQubGVuZ3RoIC0gMX1cclxuICAgICAgICAgICAgPGJ1dHRvbiBcclxuICAgICAgICAgICAgICAgIGNsYXNzOmFjdGl2ZT17JHBhZ2VOdW1iZXIgPT09IG4gKyAxfVxyXG4gICAgICAgICAgICAgICAgb246Y2xpY2s9eygpID0+IHNldFBhZ2UobiArIDEpfVxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICB7biArIDF9XHJcbiAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgICB7L2lmfVxyXG4gICAgICAgIHsvZWFjaH1cclxuXHJcbiAgICAgICAgeyNpZiBwYWdlQ291bnQubGVuZ3RoID4gNiAmJiAkcGFnZU51bWJlciA8PSBwYWdlQ291bnQubGVuZ3RoIC0gM31cclxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImVsbGlwc2VcIj4uLi48L2J1dHRvbj5cclxuICAgICAgICB7L2lmfVxyXG5cclxuICAgICAgICB7I2lmIHBhZ2VDb3VudC5sZW5ndGggPiAxfVxyXG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzOmFjdGl2ZT17JHBhZ2VOdW1iZXIgPT09IHBhZ2VDb3VudC5sZW5ndGh9IG9uOmNsaWNrPXsoKSA9PiBzZXRQYWdlKHBhZ2VDb3VudC5sZW5ndGgpfT5cclxuICAgICAgICAgICAgICAgIHtwYWdlQ291bnQubGVuZ3RofVxyXG4gICAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICB7L2lmfVxyXG5cclxuICAgICAgICA8YnV0dG9uIFxyXG4gICAgICAgICAgICBjbGFzcz1cInRleHRcIlxyXG4gICAgICAgICAgICBjbGFzczpkaXNhYmxlZD17JHBhZ2VOdW1iZXIgPT09IHBhZ2VDb3VudC5sZW5ndGh9XHJcbiAgICAgICAgICAgIG9uOmNsaWNrPXsoKSA9PiBzZXRQYWdlKCRwYWdlTnVtYmVyICsgMSl9XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgICB7QGh0bWwgJG9wdGlvbnMubGFiZWxzLm5leHR9XHJcbiAgICAgICAgPC9idXR0b24+XHJcbiAgICA8L3NlY3Rpb24+XHJcbns6ZWxzZX1cclxuICAgIDxzZWN0aW9uIGNsYXNzPVwiZHQtcGFnaW5hdGlvbi1idXR0b25zIG1vYmlsZSB7Y2xhc3NMaXN0fVwiIGNsYXNzOmNzcz17JG9wdGlvbnMuY3NzfT5cclxuICAgICAgICA8YnV0dG9uIGNsYXNzOmRpc2FibGVkPXskcGFnZU51bWJlciA9PT0gMX0gb246Y2xpY2s9eygpID0+IHNldFBhZ2UoMSl9PiYjMTAwOTI7JiMxMDA5Mjs8L2J1dHRvbj5cclxuICAgICAgICA8YnV0dG9uIGNsYXNzOmRpc2FibGVkPXskcGFnZU51bWJlciA9PT0gMX0gb246Y2xpY2s9eygpID0+IHNldFBhZ2UoJHBhZ2VOdW1iZXIgLSAxKX0+JiMxMDA5NDs8L2J1dHRvbj5cclxuICAgICAgICA8YnV0dG9uIGNsYXNzOmRpc2FibGVkPXskcGFnZU51bWJlciA9PT0gcGFnZUNvdW50Lmxlbmd0aH0gIG9uOmNsaWNrPXsoKSA9PiBzZXRQYWdlKCRwYWdlTnVtYmVyICsgMSl9PiYjMTAwOTU7PC9idXR0b24+XHJcbiAgICAgICAgPGJ1dHRvbiBjbGFzczpkaXNhYmxlZD17JHBhZ2VOdW1iZXIgPT09IHBhZ2VDb3VudC5sZW5ndGh9ICBvbjpjbGljaz17KCkgPT4gc2V0UGFnZShwYWdlQ291bnQubGVuZ3RoKX0+JiMxMDA5MzsmIzEwMDkzOzwvYnV0dG9uPlxyXG4gICAgPC9zZWN0aW9uPlxyXG57L2lmfSAgICAgICAgICAgXHJcblxyXG48c3R5bGU+XHJcbiAgICBzZWN0aW9ue2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpyb3c7fVxyXG4gICAgLmNzc3toZWlnaHQ6MzJweDttYXJnaW4tcmlnaHQ6MTZweDt9XHJcbiAgICAuY3NzIGJ1dHRvbntiYWNrZ3JvdW5kOmluaGVyaXQ7aGVpZ2h0OjMycHg7d2lkdGg6MzJweDtjb2xvcjojNjE2MTYxO2ZvbnQtc2l6ZToxM3B4O21hcmdpbjowO3BhZGRpbmc6MDt0cmFuc2l0aW9uOmFsbCwgLjJzO2xpbmUtaGVpZ2h0OjMycHg7Ym9yZGVyOjFweCBzb2xpZCAjZTBlMGUwO2JvcmRlci1yaWdodDpub25lO291dGxpbmU6bm9uZTt9XHJcbiAgICAuY3NzIGJ1dHRvbjpmaXJzdC1jaGlsZHtib3JkZXItcmFkaXVzOjRweCAwIDAgNHB4O31cclxuICAgIC5jc3MgYnV0dG9uOmxhc3QtY2hpbGR7Ym9yZGVyLXJpZ2h0OjFweCBzb2xpZCAjZTBlMGUwO2JvcmRlci1yYWRpdXM6MCA0cHggNHB4IDA7fVxyXG4gICAgLmNzcyBidXR0b246bm90KC5hY3RpdmUpOmhvdmVye2JhY2tncm91bmQ6I2VlZTtjdXJzb3I6cG9pbnRlcjt9XHJcbiAgICAuY3NzIGJ1dHRvbi50ZXh0e3dpZHRoOmF1dG87bWluLXdpZHRoOjcwcHg7Y3Vyc29yOnBvaW50ZXI7fVxyXG4gICAgLmNzcyBidXR0b24uZWxsaXBzZTpob3ZlcntiYWNrZ3JvdW5kOmluaGVyaXQ7Y3Vyc29yOiBkZWZhdWx0O31cclxuICAgIC5jc3MgYnV0dG9uLmFjdGl2ZXtiYWNrZ3JvdW5kOiNlZWU7Zm9udC13ZWlnaHQ6Ym9sZDt9XHJcbiAgICAuY3NzIGJ1dHRvbi5kaXNhYmxlZDpob3ZlcntiYWNrZ3JvdW5kOmluaGVyaXQ7Y3Vyc29yOiBkZWZhdWx0O31cclxuICAgIC5jc3MubW9iaWxlIGJ1dHRvbi5kaXNhYmxlZHtjb2xvcjojYmRiZGJkO31cclxuICAgIC5jc3MubW9iaWxlIGJ1dHRvbntmb250LXdlaWdodDpib2xkO31cclxuPC9zdHlsZT5cclxuIiwiPHNjcmlwdD5cclxuICAgIGltcG9ydCBQYWdpbmF0aW9uUm93Q291bnQgZnJvbSBcIi4uL1BhZ2luYXRpb25Sb3dDb3VudC5zdmVsdGVcIlxyXG4gICAgaW1wb3J0IFBhZ2luYXRpb25CdXR0b25zIGZyb20gXCIuLi9QYWdpbmF0aW9uQnV0dG9ucy5zdmVsdGVcIlxyXG4gICAgaW1wb3J0IHsgb3B0aW9ucyB9IGZyb20gXCIuLi9zdG9yZXMvb3B0aW9ucy5qc1wiXHJcbjwvc2NyaXB0PlxyXG5cclxueyNpZiAkb3B0aW9ucy5wYWdpbmF0aW9uICYmICgkb3B0aW9ucy5ibG9ja3MucGFnaW5hdGlvblJvd0NvdW50IHx8ICRvcHRpb25zLmJsb2Nrcy5wYWdpbmF0aW9uQnV0dG9ucyl9XHJcbiAgICA8c2VjdGlvbiBjbGFzcz1cImR0LXBhZ2luYXRpb25cIiBjbGFzczpjc3M9eyRvcHRpb25zLmNzc30+XHJcbiAgICAgICAgeyNpZiAkb3B0aW9ucy5ibG9ja3MucGFnaW5hdGlvblJvd0NvdW50fVxyXG4gICAgICAgICAgICA8UGFnaW5hdGlvblJvd0NvdW50IC8+XHJcbiAgICAgICAgezplbHNlfVxyXG4gICAgICAgICAgICA8ZGl2IC8+XHJcbiAgICAgICAgey9pZn1cclxuICAgICAgICB7I2lmICRvcHRpb25zLmJsb2Nrcy5wYWdpbmF0aW9uQnV0dG9uc31cclxuICAgICAgICAgICAgPFBhZ2luYXRpb25CdXR0b25zIC8+XHJcbiAgICAgICAgey9pZn1cclxuICAgIDwvc2VjdGlvbj5cclxuey9pZn1cclxuXHJcbjxzdHlsZT5cclxuICAgIHNlY3Rpb24ge1xyXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IHJvdztcclxuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XHJcbiAgICAgICAgaGVpZ2h0OiA0MHB4O1xyXG4gICAgICAgIHBhZGRpbmctdG9wOiA4cHg7XHJcbiAgICB9XHJcbiAgICAuY3Nze1xyXG4gICAgICAgIGJhY2tncm91bmQ6ICNmZmY7XHJcbiAgICB9XHJcbjwvc3R5bGU+XHJcbiIsImV4cG9ydCBjb25zdCBoZWFkZXIgPSB7XHJcbiAgICByZW1vdmVPcmlnaW5hbFRoZWFkOiAoKSA9PiB7XHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRoZWFkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmRhdGF0YWJsZSB0YWJsZSB0aGVhZCcpXHJcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbkhlaWdodCA9IHRoZWFkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodFxyXG4gICAgICAgICAgICAvLyBjb25zdCB0YWJsZUNvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3NlY3Rpb24uZGF0YXRhYmxlIC5kdC10YWJsZScpXHJcbiAgICAgICAgICAgIC8vIGNvbnN0IHNjcm9sbFhIZWlnaHQgPSB0YWJsZUNvbnRhaW5lci5vZmZzZXRIZWlnaHQgLSB0YWJsZUNvbnRhaW5lci5jbGllbnRIZWlnaHRcclxuICAgICAgICAgICAgLy8gLSAoc2Nyb2xsWEhlaWdodCA+IDUgPyBzY3JvbGxYSGVpZ2h0ICsgMTAgOiAxKVxyXG4gICAgICAgICAgICB0aGVhZC5wYXJlbnROb2RlLnN0eWxlLm1hcmdpblRvcCA9ICctJyArIChvcmlnaW5IZWlnaHQpICsgJ3B4J1xyXG4gICAgICAgICAgICB0aGVhZC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbidcclxuICAgICAgICB9LCA1MClcclxuICAgIH0sXHJcbiAgICBnZXRPcmdpbmFsVEhlYWRDbGFzc0xpc3Q6ICgpID0+IHtcclxuICAgICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmRhdGF0YWJsZSB0YWJsZSB0aGVhZCcpLmNsYXNzTGlzdFxyXG4gICAgfSxcclxufSIsIjxzY3JpcHQ+XHJcbiAgICBpbXBvcnQgeyBvcHRpb25zIH0gZnJvbSAnLi4vc3RvcmVzL29wdGlvbnMuanMnXHJcbiAgICBpbXBvcnQgeyBjb2x1bW5zIH0gZnJvbSAnLi4vc3RvcmVzL2NvbHVtbnMuanMnXHJcbiAgICBpbXBvcnQgeyBoZWFkZXIgfSBmcm9tICcuL2hlYWRlci5qcydcclxuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tICdzdmVsdGUnXHJcbiAgICBsZXQgdGhlYWRDbGFzc0xpc3RcclxuICAgIG9uTW91bnQoKCkgPT4ge1xyXG4gICAgICAgIGNvbHVtbnMuZHJhdygpXHJcbiAgICAgICAgaGVhZGVyLnJlbW92ZU9yaWdpbmFsVGhlYWQoKVxyXG4gICAgICAgIHRoZWFkQ2xhc3NMaXN0ID0gaGVhZGVyLmdldE9yZ2luYWxUSGVhZENsYXNzTGlzdCgpXHJcbiAgICB9KVxyXG48L3NjcmlwdD5cclxuXHJcbjxzZWN0aW9uIGNsYXNzPVwiZHQtaGVhZGVyXCIgY2xhc3M6c29ydGFibGU9eyRvcHRpb25zLnNvcnRhYmxlID09PSB0cnVlfSBjbGFzczpjc3M9eyRvcHRpb25zLmNzc30+XHJcbiAgICA8dGhlYWQgY2xhc3M9e3RoZWFkQ2xhc3NMaXN0fT5cclxuICAgICAgICA8dHI+XHJcbiAgICAgICAgICAgIHsjZWFjaCAkY29sdW1ucyBhcyB0aH1cclxuICAgICAgICAgICAgICAgIDx0aFxyXG4gICAgICAgICAgICAgICAgICAgIG5vd3JhcFxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlPVwibWluLXdpZHRoOnt0aC5taW5XaWR0aH1weFwiXHJcbiAgICAgICAgICAgICAgICAgICAgb246Y2xpY2s9eyhlKSA9PiBjb2x1bW5zLnNvcnQoZS50YXJnZXQsIHRoLmtleSl9XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9e3RoLmNsYXNzTGlzdH1cclxuICAgICAgICAgICAgICAgICAgICBjbGFzczpzb3J0YWJsZT17dGgua2V5ICYmICRvcHRpb25zLnNvcnRhYmxlID09PSB0cnVlfVxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgIHtAaHRtbCB0aC5odG1sfTxzcGFuIC8+XHJcbiAgICAgICAgICAgICAgICA8L3RoPlxyXG4gICAgICAgICAgICB7L2VhY2h9XHJcbiAgICAgICAgPC90cj5cclxuICAgICAgICB7I2lmICRvcHRpb25zLmNvbHVtbkZpbHRlciA9PT0gdHJ1ZX1cclxuICAgICAgICAgICAgPHRyPlxyXG4gICAgICAgICAgICAgICAgeyNlYWNoICRjb2x1bW5zIGFzIHRofVxyXG4gICAgICAgICAgICAgICAgICAgIDx0aCBjbGFzcz1cImZpbHRlclwiIHN0eWxlPVwid2lkdGg6e3RoLndpZHRofTtoZWlnaHQ6MjVweDtcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgeyNpZiB0aC5rZXl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwidGV4dFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9eyRvcHRpb25zLmxhYmVscy5maWx0ZXJ9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJicm93c2VyLWRlZmF1bHRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOmlucHV0PXsoZSkgPT4gY29sdW1ucy5maWx0ZXIodGgua2V5LCBlLnRhcmdldC52YWx1ZSl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7L2lmfVxyXG4gICAgICAgICAgICAgICAgICAgIDwvdGg+XHJcbiAgICAgICAgICAgICAgICB7L2VhY2h9XHJcbiAgICAgICAgICAgIDwvdHI+XHJcbiAgICAgICAgey9pZn1cclxuICAgIDwvdGhlYWQ+XHJcbjwvc2VjdGlvbj5cclxuXHJcbjxzdHlsZT5cclxuICAgIHNlY3Rpb24ge1xyXG4gICAgICAgIHBvc2l0aW9uOiAtd2Via2l0LXN0aWNreTtcclxuICAgICAgICBwb3NpdGlvbjogc3RpY2t5O1xyXG4gICAgICAgIHRvcDogMDtcclxuICAgICAgICBsZWZ0OiAwO1xyXG4gICAgICAgIHotaW5kZXg6IDY7XHJcbiAgICAgICAgYmFja2dyb3VuZDogaW5oZXJpdDtcclxuICAgIH1cclxuICAgIC5jc3MgdGgge1xyXG4gICAgICAgIHBhZGRpbmc6IDhweCAwcHggOHB4IDE2cHg7XHJcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xyXG4gICAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZWVlO1xyXG4gICAgICAgIGJhY2tncm91bmQ6ICNmZmY7XHJcbiAgICB9XHJcbiAgICAuY3NzIHRoLnNvcnRhYmxlIHtcclxuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICB9XHJcbiAgICAuY3NzIHRoLnNvcnRhYmxlIHNwYW4ge1xyXG4gICAgICAgIHBhZGRpbmctcmlnaHQ6IDE2cHg7XHJcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gICAgfVxyXG4gICAgLmNzcyB0aC5zb3J0YWJsZSBzcGFuOmJlZm9yZSxcclxuICAgIC5jc3MgdGguc29ydGFibGUgc3BhbjphZnRlciB7XHJcbiAgICAgICAgYm9yZGVyOiA0cHggc29saWQgdHJhbnNwYXJlbnQ7XHJcbiAgICAgICAgY29udGVudDogJyc7XHJcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XHJcbiAgICAgICAgaGVpZ2h0OiAwO1xyXG4gICAgICAgIHJpZ2h0OiAwO1xyXG4gICAgICAgIHRvcDogNTAlO1xyXG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgICAgICB3aWR0aDogMDtcclxuICAgIH1cclxuICAgIC5jc3MgdGguc29ydGFibGUgc3BhbjpiZWZvcmUge1xyXG4gICAgICAgIGJvcmRlci1ib3R0b20tY29sb3I6ICNlMGUwZTA7XHJcbiAgICAgICAgbWFyZ2luLXRvcDogLTlweDtcclxuICAgIH1cclxuICAgIC5jc3MgdGguc29ydGFibGUgc3BhbjphZnRlciB7XHJcbiAgICAgICAgYm9yZGVyLXRvcC1jb2xvcjogI2UwZTBlMDtcclxuICAgICAgICBtYXJnaW4tdG9wOiAxcHg7XHJcbiAgICB9XHJcbiAgICAuY3NzIHRoLnNvcnRhYmxlLmFzYyBzcGFuOmJlZm9yZSB7XHJcbiAgICAgICAgYm9yZGVyLWJvdHRvbS1jb2xvcjogIzllOWU5ZTtcclxuICAgIH1cclxuICAgIC5jc3MgdGguc29ydGFibGUuZGVzYyBzcGFuOmFmdGVyIHtcclxuICAgICAgICBib3JkZXItdG9wLWNvbG9yOiAjOWU5ZTllO1xyXG4gICAgfVxyXG4gICAgLmNzcyB0aC5maWx0ZXIge1xyXG4gICAgICAgIHBhZGRpbmc6IDA7XHJcbiAgICAgICAgbWFyZ2luOiAwO1xyXG4gICAgICAgIGJhY2tncm91bmQtaW1hZ2U6IG5vbmU7XHJcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgI2ZhZmFmYTtcclxuICAgIH1cclxuICAgIHRoLmZpbHRlciBpbnB1dCB7XHJcbiAgICAgICAgbWFyZ2luOiAwO1xyXG4gICAgICAgIHBhZGRpbmc6IDA7XHJcbiAgICAgICAgd2lkdGg6IDEwMCU7XHJcbiAgICB9XHJcbiAgICAuY3NzIHRoLmZpbHRlciBpbnB1dCB7XHJcbiAgICAgICAgYmFja2dyb3VuZDogI2ZmZjtcclxuICAgICAgICBoZWlnaHQ6IDI0cHg7XHJcbiAgICAgICAgYm9yZGVyOiBub25lO1xyXG4gICAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZWVlO1xyXG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcclxuICAgICAgICBvdXRsaW5lOiBub25lO1xyXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDA7XHJcbiAgICAgICAgZm9udC1zaXplOiAxNHB4O1xyXG4gICAgfVxyXG4gICAgLmNzcyB0aC5maWx0ZXIgaW5wdXQ6OnBsYWNlaG9sZGVyIHtcclxuICAgICAgICBjb2xvcjogI2JkYmRiZDtcclxuICAgICAgICBmb250LXN0eWxlOiBpdGFsaWM7XHJcbiAgICAgICAgZm9udC1zaXplOiAxM3B4O1xyXG4gICAgfVxyXG48L3N0eWxlPlxyXG4iLCI8c2NyaXB0PlxyXG5cdGltcG9ydCB7IG9wdGlvbnMgfSBmcm9tICcuL3N0b3Jlcy9vcHRpb25zLmpzJ1xyXG5cdGltcG9ydCB7IGRhdGF0YWJsZSB9IGZyb20gJy4vZGF0YXRhYmxlLmpzJ1xyXG5cdGltcG9ydCBTZWFyY2ggZnJvbSAnLi9jb21wb25lbnRzL1NlYXJjaC5zdmVsdGUnXHJcblx0aW1wb3J0IFBhZ2luYXRpb24gZnJvbSAnLi9jb21wb25lbnRzL1BhZ2luYXRpb24uc3ZlbHRlJ1xyXG5cdGltcG9ydCBTdGlja3lIZWFkZXIgZnJvbSAnLi9jb21wb25lbnRzL1N0aWNreUhlYWRlci5zdmVsdGUnXHJcblx0aW1wb3J0IHsgb25Nb3VudCwgb25EZXN0cm95IH0gZnJvbSAnc3ZlbHRlJ1xyXG5cdGV4cG9ydCBsZXQgZGF0YSA9IFtdXHJcblx0ZXhwb3J0IGxldCBzZXR0aW5ncyA9IHt9XHJcblx0ZXhwb3J0IGxldCBjbGFzc0xpc3QgPSAnJ1xyXG5cdCQ6IHtcclxuXHRcdGRhdGF0YWJsZS5zZXRSb3dzKGRhdGEpXHJcblx0XHRvcHRpb25zLnVwZGF0ZShzZXR0aW5ncylcclxuXHR9XHJcblx0b25Nb3VudCgoKSA9PiBkYXRhdGFibGUuaW5pdCgpIClcclxuXHRvbkRlc3Ryb3koKCkgPT4gZGF0YXRhYmxlLnJlc2V0KCkpXHJcbjwvc2NyaXB0PlxyXG5cclxuPHNlY3Rpb24gY2xhc3M9XCJkYXRhdGFibGUge2NsYXNzTGlzdH1cIiBjbGFzczpzY3JvbGwteT17JG9wdGlvbnMuc2Nyb2xsWX0gY2xhc3M6Y3NzPXskb3B0aW9ucy5jc3N9PlxyXG5cdHsjaWYgJG9wdGlvbnMuYmxvY2tzLnNlYXJjaElucHV0ID09PSB0cnVlfVxyXG5cdFx0PFNlYXJjaCAvPlxyXG5cdHsvaWZ9XHJcblx0PGFydGljbGUgY2xhc3M9XCJkdC10YWJsZVwiPlxyXG5cdFx0eyNpZiAkb3B0aW9ucy5zY3JvbGxZfVxyXG5cdFx0XHQ8U3RpY2t5SGVhZGVyLz5cclxuXHRcdHsvaWZ9XHJcblx0XHQ8dGFibGU+XHJcblx0XHRcdDxzbG90IC8+XHJcblx0XHQ8L3RhYmxlPlxyXG5cdDwvYXJ0aWNsZT5cclxuXHR7I2lmICRvcHRpb25zLmJsb2Nrcy5wYWdpbmF0aW9uUm93Q291bnQgPT09IHRydWUgfHwgJG9wdGlvbnMuYmxvY2tzLnBhZ2luYXRpb25CdXR0b25zID09PSB0cnVlfVxyXG5cdFx0PFBhZ2luYXRpb24gLz5cclxuXHR7L2lmfVxyXG48L3NlY3Rpb24+XHJcblxyXG48c3R5bGU+XHJcblx0LmRhdGF0YWJsZSB7XHJcblx0XHRwb3NpdGlvbjogcmVsYXRpdmU7XHJcblx0fVxyXG5cdC5jc3MuZGF0YXRhYmxlIHtcclxuXHRcdGJhY2tncm91bmQ6ICNmZmY7XHJcblx0fVxyXG5cdC5kYXRhdGFibGUuc2Nyb2xsLXl7XHJcblx0XHRoZWlnaHQ6MTYwcHg7XHJcblx0fVxyXG5cdC5kYXRhdGFibGUgKiB7XHJcblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xyXG5cdH1cclxuXHRhcnRpY2xlIHtcclxuXHRcdHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuXHRcdG92ZXJmbG93LXk6IGF1dG87XHJcblx0XHRvdmVyZmxvdy14OiBoaWRkZW47XHJcblx0XHR3aWR0aDogMTAwJTtcclxuXHRcdGJhY2tncm91bmQ6IGluaGVyaXQ7XHJcblx0fVxyXG5cdC5jc3MgYXJ0aWNsZSB7XHJcblx0XHRib3JkZXItYm90dG9tOiAxcHggc29saWQgI2UwZTBlMDtcclxuXHRcdHNjcm9sbGJhci13aWR0aDogdGhpbjtcclxuXHR9XHJcblx0LmNzcyBhcnRpY2xlOjotd2Via2l0LXNjcm9sbGJhciB7XHJcblx0XHR3aWR0aDogNnB4O1xyXG5cdFx0aGVpZ2h0OiA2cHg7XHJcblx0fVxyXG5cdC5jc3MgYXJ0aWNsZTo6LXdlYmtpdC1zY3JvbGxiYXItdHJhY2sge1xyXG5cdFx0YmFja2dyb3VuZDogI2Y1ZjVmNTtcclxuXHR9XHJcblx0LmNzcyBhcnRpY2xlOjotd2Via2l0LXNjcm9sbGJhci10aHVtYiB7XHJcblx0XHRiYWNrZ3JvdW5kOiAjYzJjMmMyO1xyXG5cdH1cclxuXHQuY3NzIGFydGljbGU6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1iOmhvdmVyIHtcclxuXHRcdGJhY2tncm91bmQ6ICM5ZTllOWU7XHJcblx0fVxyXG5cdC5jc3MgYXJ0aWNsZTo6LXdlYmtpdC1zY3JvbGxiYXItdHJhY2stcGllY2U6c3RhcnQge1xyXG5cdFx0dG9wOiA0MHB4O1xyXG5cdH1cclxuXHQuY3NzIHRhYmxlIHtcclxuXHRcdHdpZHRoOiAxMDAlO1xyXG5cdFx0Ym9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcclxuXHRcdG92ZXJmbG93OiBoaWRkZW47XHJcblx0XHRtYXJnaW4tYm90dG9tOiA2cHg7XHJcblx0fVxyXG48L3N0eWxlPlxyXG4iLCI8c2NyaXB0PlxyXG4gIGltcG9ydCB7IERhdGF0YWJsZSwgcm93cyB9IGZyb20gJ3N2ZWx0ZS1zaW1wbGUtZGF0YXRhYmxlcyc7XHJcbiAgaW1wb3J0IHsgRWRpdEljb24sIFRyYXNoMkljb24gfSBmcm9tICdzdmVsdGUtZmVhdGhlci1pY29ucyc7XHJcbiAgaW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyIH0gZnJvbSBcInN2ZWx0ZVwiO1xyXG4gIGxldCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xyXG5cclxuICBsZXQgaWQ7XHJcbiAgZXhwb3J0IGxldCBpdGVtcyA9IFtdO1xyXG5cclxuICBjb25zdCBzZXR0aW5ncyA9IHtcclxuICAgIHNvcnRhYmxlOiB0cnVlLFxyXG4gICAgcGFnaW5hdGlvbjogdHJ1ZSxcclxuICAgIHJvd1BlclBhZ2U6IDEwLFxyXG4gICAgY29sdW1uRmlsdGVyOiBmYWxzZSxcclxuICB9XHJcblxyXG4gIGNvbnN0IGhhbmRsZVVwZGF0ZSA9IGFzeW5jIChpZCkgPT4ge1xyXG4gICAgbGV0IGl0ZW0gPSBpdGVtcy5maW5kKGl0ZW0gPT4gaXRlbS5pZCA9PSBpZCk7XHJcbiAgICBsZXQgZGF0YSA9IHtcclxuICAgICAgJ2l0ZW0nOiBpdGVtLFxyXG4gICAgICAnc3RhdHVzJzogJ3VwZGF0ZSdcclxuICAgIH07XHJcblxyXG4gICAgZGlzcGF0Y2goJ3VwZGF0ZScsIGRhdGEpO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgaGFuZGxlUmVtb3ZlID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgZGlzcGF0Y2goJ3JlbW92ZScsIGlkKTtcclxuXHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgaHR0cDovLzEyNy4wLjAuMTo4MDAwL2FwaS9pdGVtcy8ke2lkfWAsIHtcclxuICAgICAgbWV0aG9kOiAnZGVsZXRlJyxcclxuICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBmb3JtYXREYXRlID0gKHYpID0+IHtcclxuICAgIGxldCBkYXRlID0gbmV3IERhdGUodikudG9Mb2NhbGVTdHJpbmcoJ2lkLUlEJywgeyBcclxuICAgICAgZGF0ZVN0eWxlOidtZWRpdW0nXHJcbiAgICB9KTtcclxuICAgIGxldCByZXN1bHQgPSBkYXRlO1xyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuPC9zY3JpcHQ+XHJcblxyXG48RGF0YXRhYmxlIHtzZXR0aW5nc30gZGF0YT17aXRlbXN9PlxyXG4gIDx0aGVhZD5cclxuICAgIDx0aCBkYXRhLWtleT1cIm5hbWVcIj5OYW1lPC90aD5cclxuICAgIDx0aCBkYXRhLWtleT1cImRlc2NyaXB0aW9uXCI+RGVzY3JpcHRpb248L3RoPlxyXG4gICAgPHRoIGRhdGEta2V5PVwicHJpY2VcIj5QcmljZTwvdGg+XHJcbiAgICA8dGggZGF0YS1rZXk9XCJzdG9ja1wiPlN0b2NrPC90aD5cclxuICAgIDx0aCBkYXRhLWtleT1cImNyZWF0ZWRfYXRcIj5DcmVhdGVkIGF0PC90aD5cclxuICAgIDx0aCBkYXRhLWtleT1cInVwZGF0ZWRfYXRcIj5VcGRhdGVkIGF0PC90aD5cclxuICAgIDx0aD5BY3Rpb248L3RoPlxyXG4gIDwvdGhlYWQ+XHJcbiAgPHRib2R5PlxyXG4gICAgeyNlYWNoICRyb3dzIGFzIHJvd31cclxuICAgIDx0cj5cclxuICAgICAgPHRkPntyb3cubmFtZX08L3RkPlxyXG4gICAgICA8dGQ+e3Jvdy5kZXNjcmlwdGlvbn08L3RkPlxyXG4gICAgICA8dGQ+e3Jvdy5wcmljZX08L3RkPlxyXG4gICAgICA8dGQ+e3Jvdy5zdG9ja308L3RkPlxyXG4gICAgICA8dGQ+e2Zvcm1hdERhdGUocm93LmNyZWF0ZWRfYXQpfTwvdGQ+XHJcbiAgICAgIDx0ZD57Zm9ybWF0RGF0ZShyb3cudXBkYXRlZF9hdCl9PC90ZD5cclxuICAgICAgPHRkPlxyXG4gICAgICAgICAgPGRpdiBjbGFzcz1cImQtZmxleCBqdXN0aWZ5LWNvbnRlbnQtY2VudGVyXCI+XHJcbiAgICAgICAgICAgIDxhIGNsYXNzPVwibWUtM1wiIG9uOmNsaWNrPXsoKSA9PiB7aGFuZGxlVXBkYXRlKHJvdy5pZCl9fT48RWRpdEljb24gY2xhc3M9XCJhbGlnbi1taWRkbGUgdGV4dC1zdWNjZXNzXCIgLz48L2E+XHJcbiAgICAgICAgICAgIDxhIGRhdGEtYnMtdG9nZ2xlPVwibW9kYWxcIiBkYXRhLWJzLXRhcmdldD1cIiNkZWxldGVNb2RhbFwiIG9uOmNsaWNrPXsoKSA9PiB7aWQgPSByb3cuaWR9fT48VHJhc2gySWNvbiBjbGFzcz1cImFsaWduLW1pZGRsZSB0ZXh0LWRhbmdlclwiIC8+PC9hPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC90ZD5cclxuICAgIDwvdHI+XHJcbiAgICB7L2VhY2h9XHJcbiAgPC90Ym9keT5cclxuPC9EYXRhdGFibGU+XHJcblxyXG48ZGl2IGNsYXNzPVwibW9kYWwgZmFkZVwiIGlkPVwiZGVsZXRlTW9kYWxcIiB0YWJpbmRleD1cIi0xXCIgYXJpYS1sYWJlbGxlZGJ5PVwiZXhhbXBsZU1vZGFsTGFiZWxcIiBhcmlhLWhpZGRlbj1cInRydWVcIj5cclxuICA8ZGl2IGNsYXNzPVwibW9kYWwtZGlhbG9nIG1vZGFsLWRpYWxvZy1jZW50ZXJlZCBtb2RhbC1zbVwiPlxyXG4gICAgPGRpdiBjbGFzcz1cIm1vZGFsLWNvbnRlbnRcIj5cclxuICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWhlYWRlclwiPlxyXG4gICAgICAgIDxoNSBjbGFzcz1cIm1vZGFsLXRpdGxlXCIgaWQ9XCJleGFtcGxlTW9kYWxMYWJlbFwiPk1vZGFsIHRpdGxlPC9oNT5cclxuICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0bi1jbG9zZVwiIGRhdGEtYnMtZGlzbWlzcz1cIm1vZGFsXCIgYXJpYS1sYWJlbD1cIkNsb3NlXCI+PC9idXR0b24+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtYm9keVwiPlxyXG4gICAgICAgIGFyZSB1IHN1cmUgZGVsZXRlIHRoaXMgaXRlbT9cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1mb290ZXJcIj5cclxuICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tc2Vjb25kYXJ5XCIgZGF0YS1icy1kaXNtaXNzPVwibW9kYWxcIj5ubzwvYnV0dG9uPlxyXG4gICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1kYW5nZXJcIiBvbjpjbGljaz17aGFuZGxlUmVtb3ZlfSBkYXRhLWJzLWRpc21pc3M9XCJtb2RhbFwiPnllczwvYnV0dG9uPlxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG4gIDwvZGl2PlxyXG48L2Rpdj4iLCI8c2NyaXB0PlxyXG4gIGV4cG9ydCBsZXQgbmFtZTtcclxuICBleHBvcnQgbGV0IGxhYmVsO1xyXG4gIGV4cG9ydCBsZXQgdHlwZTtcclxuICBleHBvcnQgbGV0IHZhbHVlO1xyXG4gIGV4cG9ydCBsZXQgcm93cyA9IDM7XHJcbiAgZXhwb3J0IGxldCB2YWxpZCA9ICd1bmRlZmluZWQnO1xyXG4gIGV4cG9ydCBsZXQgaW52YWxpZCA9ICd1bmRlZmluZWQnO1xyXG5cclxuICBjb25zdCBoYW5kbGVJbnB1dCA9IGUgPT4ge1xyXG4gICAgdmFsdWUgPSBlLnRhcmdldC52YWx1ZTtcclxuICB9O1xyXG48L3NjcmlwdD5cclxuXHJcbjxkaXYgY2xhc3M9XCJtYi0zXCI+XHJcbiAgPGxhYmVsIGZvcj17bmFtZX0gY2xhc3M9XCJmb3JtLWxhYmVsXCI+e2xhYmVsfTwvbGFiZWw+XHJcbiAgeyNpZiB0eXBlID09PSBcInRleHRhcmVhXCJ9XHJcbiAgICA8dGV4dGFyZWEgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBpZD17bmFtZX0ge3Jvd3N9IG9uOmlucHV0PXtoYW5kbGVJbnB1dH0ge3ZhbHVlfSBhdXRvY29tcGxldGU9XCJvZmZcIiByZXF1aXJlZD48L3RleHRhcmVhPlxyXG4gIHs6ZWxzZX1cclxuICAgIDxpbnB1dCB7dHlwZX0gY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBpZD17bmFtZX0gb246aW5wdXQ9e2hhbmRsZUlucHV0fSB7dmFsdWV9IGF1dG9jb21wbGV0ZT1cIm9mZlwiIHJlcXVpcmVkPlxyXG4gIHsvaWZ9XHJcbiAgeyNpZiB2YWxpZCAhPT0gJ3VuZGVmaW5lZCd9XHJcbiAgICA8ZGl2IGNsYXNzPVwidmFsaWQtZmVlZGJhY2tcIj5cclxuICAgICAge3ZhbGlkfVxyXG4gICAgPC9kaXY+XHJcbiAgey9pZn1cclxuICB7I2lmIGludmFsaWQgIT09ICd1bmRlZmluZWQnfVxyXG4gICAgPGRpdiBjbGFzcz1cImludmFsaWQtZmVlZGJhY2tcIj5cclxuICAgICAge2ludmFsaWR9XHJcbiAgICA8L2Rpdj5cclxuICB7L2lmfVxyXG48L2Rpdj5cclxuIiwiPHNjcmlwdD5cclxuICBpbXBvcnQgRmllbGQgZnJvbSAnLi4vcGFydGlhbHMvRmllbGQuc3ZlbHRlJztcclxuICBpbXBvcnQgeyBvbk1vdW50LCBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tIFwic3ZlbHRlXCI7XHJcbiAgbGV0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XHJcbiAgXHJcbiAgZXhwb3J0IGxldCBzdGF0dXMgPSAnc3RvcmUnO1xyXG4gIGV4cG9ydCBsZXQgZGF0YSA9IHtcclxuICAgICduYW1lJyAgICAgICAgOiAnJyxcclxuICAgICdkZXNjcmlwdGlvbicgOiAnJyxcclxuICAgICdwcmljZScgICAgICAgOiAnJyxcclxuICAgICdzdG9jaycgICAgICAgOiAnJ1xyXG4gIH07XHJcblxyXG4gIGxldCBzdWJtaXQ7XHJcblxyXG4gIGNvbnN0IHN0b3JlSXRlbSA9IGFzeW5jICgpID0+IHtcclxuICAgIGxldCBtZXRob2QgPSBzdGF0dXMgPT09ICdzdG9yZScgPyAncG9zdCcgOiAncHV0JztcclxuICAgIGxldCB1cmwgPSBzdGF0dXMgPT09ICdzdG9yZScgPyAnaHR0cDovLzEyNy4wLjAuMTo4MDAwL2FwaS9pdGVtcycgOiBgaHR0cDovLzEyNy4wLjAuMTo4MDAwL2FwaS9pdGVtcy8ke2RhdGEuaWR9YDtcclxuXHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIHtcclxuICAgICAgbWV0aG9kOiBtZXRob2QsXHJcbiAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXHJcbiAgICAgIH0sXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXMuanNvbigpO1xyXG4gICAgZGF0YSA9IGpzb24uZGF0YTtcclxuXHJcbiAgICBpZiAoc3RhdHVzID09PSAnc3RvcmUnKSB7XHJcbiAgICAgIGRpc3BhdGNoKCdhZGQnLCBkYXRhKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGRpc3BhdGNoKCd1cGRhdGVkJywgZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVzZXRGb3JtKCk7XHJcbiAgfVxyXG5cclxuICBjb25zdCByZXNldEZvcm0gPSAoKSA9PiB7XHJcbiAgICBkYXRhID0ge1xyXG4gICAgICAnbmFtZScgICAgICAgIDogJycsXHJcbiAgICAgICdkZXNjcmlwdGlvbicgOiAnJyxcclxuICAgICAgJ3ByaWNlJyAgICAgICA6ICcnLFxyXG4gICAgICAnc3RvY2snICAgICAgIDogJydcclxuICAgIH1cclxuXHJcbiAgICBkaXNwYXRjaCgncmVzZXQnKTtcclxuICB9XHJcblxyXG4gIG9uTW91bnQoYXN5bmMgKCkgPT4ge1xyXG4gICAgc3VibWl0ID0gKCkgPT4ge1xyXG4gICAgICB2YXIgZm9ybXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcubmVlZHMtdmFsaWRhdGlvbicpXHJcblxyXG4gICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmb3JtcylcclxuICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoZm9ybSkge1xyXG4gICAgICAgICAgaWYgKCFmb3JtLmNoZWNrVmFsaWRpdHkoKSkge1xyXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXHJcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXHJcbiAgICAgICAgICAgIGZvcm0uY2xhc3NMaXN0LmFkZCgnd2FzLXZhbGlkYXRlZCcpXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzdG9yZUl0ZW0oKVxyXG4gICAgICAgICAgICBmb3JtLmNsYXNzTGlzdC5yZW1vdmUoJ3dhcy12YWxpZGF0ZWQnKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG48L3NjcmlwdD5cclxuXHJcbjxmb3JtIGNsYXNzPVwibmVlZHMtdmFsaWRhdGlvblwiIG9uOnN1Ym1pdHxwcmV2ZW50RGVmYXVsdD17c3VibWl0fSBub3ZhbGlkYXRlPlxyXG4gIDxGaWVsZFxyXG4gICAgbmFtZT1cIm5hbWVcIlxyXG4gICAgbGFiZWw9XCJOYW1lXCJcclxuICAgIHR5cGU9XCJ0ZXh0XCJcclxuICAgIGJpbmQ6dmFsdWU9e2RhdGEubmFtZX0gLz5cclxuICA8RmllbGRcclxuICAgIG5hbWU9XCJkZXNjXCJcclxuICAgIGxhYmVsPVwiRGVzY3JpcHRpb25cIlxyXG4gICAgdHlwZT1cInRleHRhcmVhXCJcclxuICAgIHJvd3M9M1xyXG4gICAgYmluZDp2YWx1ZT17ZGF0YS5kZXNjcmlwdGlvbn0gLz5cclxuICA8RmllbGRcclxuICAgIG5hbWU9XCJwcmljZVwiXHJcbiAgICBsYWJlbD1cIlByaWNlXCJcclxuICAgIHR5cGU9XCJudW1iZXJcIlxyXG4gICAgYmluZDp2YWx1ZT17ZGF0YS5wcmljZX0gLz5cclxuICA8RmllbGRcclxuICAgIG5hbWU9XCJzdG9ja1wiXHJcbiAgICBsYWJlbD1cIlN0b2NrXCJcclxuICAgIHR5cGU9XCJudW1iZXJcIlxyXG4gICAgYmluZDp2YWx1ZT17ZGF0YS5zdG9ja30gLz5cclxuICA8ZGl2IGNsYXNzPVwibXQtNCBkLWZsZXgganVzdGlmeS1jb250ZW50LWJldHdlZW5cIj5cclxuICAgIDxidXR0b25cclxuICAgICAgdHlwZT1cInN1Ym1pdFwiXHJcbiAgICAgIGNsYXNzPVwiYnRuIGJ0bi1wcmltYXJ5XCI+XHJcbiAgICAgIHsjaWYgc3RhdHVzID09PSAnc3RvcmUnfVxyXG4gICAgICAgIEFkZCBJdGVtXHJcbiAgICAgIHs6ZWxzZX1cclxuICAgICAgICBVcGRhdGUgSXRlbVxyXG4gICAgICB7L2lmfVxyXG4gICAgPC9idXR0b24+XHJcbiAgICA8YSBjbGFzcz1cImJ0biBidG4tZGFuZ2VyXCIgb246Y2xpY2s9e3Jlc2V0Rm9ybX0+UmVzZXQ8L2E+XHJcbiAgPC9kaXY+XHJcbjwvZm9ybT4iLCI8c3ZlbHRlOmhlYWQ+XHJcbiAgPHRpdGxlPkl0ZW08L3RpdGxlPlxyXG48L3N2ZWx0ZTpoZWFkPlxyXG5cclxuPHNjcmlwdCBjb250ZXh0PVwibW9kdWxlXCI+XHJcbiAgZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByZWxvYWQoKSB7XHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmZldGNoKCdodHRwOi8vMTI3LjAuMC4xOjgwMDAvYXBpL2l0ZW1zJyk7XHJcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcclxuXHJcbiAgICBpZiAocmVzLnN0YXR1cyA9PT0gMjAwKSB7XHJcbiAgICAgIHJldHVybiB7IFxyXG4gICAgICAgIG1lc3NhZ2U6IGRhdGEubWVzc2FnZSxcclxuICAgICAgICBpdGVtczogZGF0YS5kYXRhXHJcbiAgICAgIH07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmVycm9yKHJlcy5zdGF0dXMsIGRhdGEubWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgfVxyXG48L3NjcmlwdD5cclxuXHJcbjxzY3JpcHQ+XHJcbiAgaW1wb3J0IEl0ZW1UYWJsZSBmcm9tICcuLi8uLi9jb21wb25lbnRzL3RhYmxlcy9pdGVtLnN2ZWx0ZSc7XHJcbiAgaW1wb3J0IEl0ZW1Gb3JtIGZyb20gJy4uLy4uL2NvbXBvbmVudHMvZm9ybXMvaXRlbS5zdmVsdGUnO1xyXG5cclxuICBleHBvcnQgbGV0IGl0ZW1zID0gW107XHJcbiAgbGV0IGRhdGE7XHJcbiAgbGV0IHN0YXR1cztcclxuXHJcbiAgY29uc3QgaGFuZGxlQWRkID0gKGUpID0+IHtcclxuICAgIGxldCBpdGVtID0gZS5kZXRhaWw7XHJcbiAgICBpdGVtcyA9IFsuLi5pdGVtcywgaXRlbV07XHJcbiAgfVxyXG5cclxuICBjb25zdCBoYW5kbGVSZW1vdmUgPSAoZSkgPT4ge1xyXG4gICAgaXRlbXMgPSBpdGVtcy5maWx0ZXIoaXRlbSA9PiBpdGVtLmlkICE9IGUuZGV0YWlsKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IGhhbmRsZVVwZGF0ZSA9IChlKSA9PiB7XHJcbiAgICBkYXRhID0gZS5kZXRhaWwuaXRlbTtcclxuICAgIHN0YXR1cyA9IGUuZGV0YWlsLnN0YXR1cztcclxuICB9XHJcblxyXG4gIGNvbnN0IGhhbmRsZVVwZGF0ZWQgPSAoZSkgPT4ge1xyXG4gICAgbGV0IGN1cnJlbnRJdGVtID0gaXRlbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbS5pZCA9PSBlLmRldGFpbC5pZCk7XHJcblxyXG4gICAgaXRlbXMgPSBpdGVtcy5tYXAoaXRlbSA9PiB7XHJcbiAgICAgIGlmIChKU09OLnN0cmluZ2lmeShpdGVtKSA9PT0gSlNPTi5zdHJpbmdpZnkoY3VycmVudEl0ZW1bMF0pKSB7XHJcbiAgICAgICAgcmV0dXJuIGUuZGV0YWlsO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBpdGVtO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBzdGF0dXMgPSAnc3RvcmUnO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgaGFuZGxlUmVzZXQgPSAoKSA9PiB7XHJcbiAgICBzdGF0dXMgPSAnc3RvcmUnO1xyXG4gIH1cclxuPC9zY3JpcHQ+XHJcblxyXG48ZGl2IGNsYXNzPVwiY29udGFpbmVyXCI+XHJcbiAgPGRpdiBjbGFzcz1cInJvd1wiPlxyXG4gICAgPGRpdiBjbGFzcz1cImNvbC1tZC04IGNvbC1zbS0xMlwiPlxyXG4gICAgICA8ZGl2IGNsYXNzPVwiY2FyZCBzaGFkb3cgbWItNFwiPlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJjYXJkLWJvZHlcIj5cclxuICAgICAgICAgIDxJdGVtVGFibGUgb246cmVtb3ZlPXtoYW5kbGVSZW1vdmV9IG9uOnVwZGF0ZT17aGFuZGxlVXBkYXRlfSB7aXRlbXN9Lz5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtNCBjb2wtc20tMTJcIj5cclxuICAgICAgPGRpdiBjbGFzcz1cImNhcmQgc2hhZG93IG1iLTRcIj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZC1ib2R5XCI+XHJcbiAgICAgICAgICA8SXRlbUZvcm0gb246YWRkPXtoYW5kbGVBZGR9IG9uOnVwZGF0ZWQ9e2hhbmRsZVVwZGF0ZWR9IG9uOnJlc2V0PXtoYW5kbGVSZXNldH0ge3N0YXR1c30ge2RhdGF9Lz5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICA8L2Rpdj5cclxuPC9kaXY+XHJcblxyXG48c3R5bGU+XHJcbiAgLmNhcmQge1xyXG4gICAgbWluLWhlaWdodDogNzB2aDtcclxuICB9XHJcbjwvc3R5bGU+Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bUNBYStDLEdBQUk7b0NBQVUsR0FBSTs7OztpREFBd0UsR0FBVzs7O3NGQUErRSxHQUFXOzs7Ozs7Ozs7O29DQUEvTCxHQUFJOzs7O3FDQUFVLEdBQUk7Ozs7a0RBQXdFLEdBQVc7OztxSEFBK0UsR0FBVzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQVpqTyxJQUFJLEdBQUcsTUFBTTtPQUNiLFdBQVcsR0FBRyxDQUFDO2NBQ3RCLFdBQVcsR0FBRyxFQUFFOztLQUdoQixJQUFJLEtBQUssTUFBTTtFQUNqQixJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDLE1BQU0sR0FBRztJQUNyQixJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxHQUFFLENBQUMsSUFBSSxJQUFJO0lBQ3BDLFFBQVEsQ0FBQyxJQUFJLElBQUksSUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttQ0NJYyxHQUFJO29DQUFVLEdBQUk7Ozs7aURBQXdFLEdBQVc7Ozt5RkFBa0YsR0FBVzs7Ozs7Ozs7Ozs7O29DQUFsTSxHQUFJOzs7O3FDQUFVLEdBQUk7Ozs7a0RBQXdFLEdBQVc7Ozt3SEFBa0YsR0FBVzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQVpwTyxJQUFJLEdBQUcsTUFBTTtPQUNiLFdBQVcsR0FBRyxDQUFDO2NBQ3RCLFdBQVcsR0FBRyxFQUFFOztLQUdoQixJQUFJLEtBQUssTUFBTTtFQUNqQixJ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QUFNO0FBQzFCLENBQUMsTUFBTSxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsR0FBRyxRQUFRLENBQUMsRUFBRSxFQUFDO0FBQzNDLENBQUMsT0FBTztBQUNSLEVBQUUsU0FBUyxFQUFFLE1BQU07QUFDbkIsRUFBRSxHQUFHLEVBQUUsQ0FBQyxHQUFHLEVBQUUsS0FBSyxLQUFLLE1BQU0sQ0FBQyxLQUFLLElBQUk7QUFDdkMsR0FBRyxNQUFNLE1BQU0sR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBQztBQUMxQyxHQUFHLEtBQUssR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksSUFBSSxFQUFFLE9BQU8sSUFBSSxDQUFDLEdBQUcsS0FBSyxHQUFHLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLEVBQUM7QUFDckYsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBQztBQUNyQixHQUFHLE9BQU8sS0FBSztBQUNmLEdBQUcsQ0FBQztBQUNKLEVBQUUsTUFBTSxFQUFFLE1BQU0sTUFBTSxDQUFDLEtBQUssSUFBWSxFQUFFLENBQUM7QUFDM0MsRUFBRTtBQUNGLEVBQUM7QUFDTSxNQUFNLEtBQUssR0FBRyxXQUFXLEdBQUU7QUFDbEM7QUFDQSxNQUFNLFlBQVksR0FBRyxNQUFNO0FBQzNCLENBQUMsTUFBTSxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsR0FBRyxRQUFRLENBQUMsSUFBSSxFQUFDO0FBQzdDLENBQUMsT0FBTztBQUNSLEVBQUUsU0FBUztBQUNYLEVBQUUsR0FBRyxFQUFFLENBQUMsS0FBSyxLQUFLLE1BQU0sQ0FBQyxLQUFLLElBQUk7QUFDbEMsR0FBRyxLQUFLLEdBQUcsQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsSUFBSSxLQUFLLEdBQUcsS0FBSTtBQUM1QyxHQUFHLE9BQU8sS0FBSztBQUNmLEdBQUcsQ0FBQztBQUNKLEVBQUUsTUFBTSxFQUFFLE1BQU0sTUFBTSxDQUFDLEtBQUssSUFB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
